---
phase: 11-verse-by-category-system
plan: 04
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - scripts/import-verse-categories.mjs
autonomous: true

must_haves:
  truths:
    - "10 verse categories created from old DB data"
    - "All unique KJV verses imported from old versebycategory table"
    - "NIV translations from old DB preserved"
    - "All 877 CategoryPhotos.zip images uploaded to B2 and catalogued"
    - "Import script is resumable (re-running skips existing data)"
  artifacts:
    - path: "scripts/import-verse-categories.mjs"
      provides: "One-time import script: old DB verses + CategoryPhotos.zip to B2"
  key_links:
    - from: "scripts/import-verse-categories.mjs"
      to: "verse_categories, verse_category_content, verse_category_content_translations, verse_category_media tables"
      via: "mysql2 direct SQL inserts"
      pattern: "INSERT INTO verse_categor"
---

<objective>
Create the one-time import script that migrates verse-by-category data from the old database and uploads CategoryPhotos.zip images to Backblaze B2.

Purpose: Populates the new verse-by-category tables with existing content from the old platform, including all 10 categories, ~3,564 unique verses with KJV+NIV text, and 877 background images.
Output: scripts/import-verse-categories.mjs -- a standalone Node.js script following import-old-data.mjs patterns.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-verse-by-category-system/11-RESEARCH.md
@.planning/phases/11-verse-by-category-system/11-01-SUMMARY.md

Key reference:
@scripts/import-old-data.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create the verse category import script</name>
  <files>scripts/import-verse-categories.mjs</files>
  <action>
    Create `scripts/import-verse-categories.mjs` following the exact patterns of `scripts/import-old-data.mjs` for DB connection, SQL parsing, and error handling.

    **Script structure (5 phases):**

    **Phase 1: Parse old DB data**
    - Read `Old Database/freelumamedia.sql` (same readFileSync + parseTable pattern as import-old-data.mjs)
    - Parse `versebycategory` table INSERT statements
    - Extract columns: TranslationAbv, Category (enum), Book, VerseReference, VerseText, ChapterText
    - Drop AMP translation rows entirely
    - Category enum -> display name mapping:
      ```
      HopeAndEncouragement -> "Hope & Encouragement"
      AnxietyAndStress -> "Anxiety & Stress"
      FaithAndTrust -> "Faith & Trust"
      HealingAndStrength -> "Healing & Strength"
      LoveAndRelationships -> "Love & Relationships"
      GratitudeAndThanksgiving -> "Gratitude & Thanksgiving"
      ForgivenessAndMercy -> "Forgiveness & Mercy"
      PeaceAndComfort -> "Peace & Comfort"
      WisdomAndGuidance -> "Wisdom & Guidance"
      CourageAndOvercomingFear -> "Courage & Overcoming Fear"
      ```

    **Phase 2: Insert verse_categories**
    - Extract unique categories from parsed data, preserving order above
    - Generate slugs: lowercase, spaces to hyphens (e.g., "hope-encouragement")
    - Use INSERT IGNORE to be idempotent on re-run
    - Log: "Created N verse categories"

    **Phase 3: Insert verse_category_content + translations**
    - Group parsed rows by (Category, VerseReference) to get unique verses per category
    - For each unique verse:
      - Find KJV text (TranslationAbv === 'KJV'). If no KJV text, use the first available non-AMP translation.
      - Clean text: strip pilcrow marks (U+00B6), HTML tags, normalize curly quotes (`[\u2018\u2019]` -> `'`, `[\u201C\u201D]` -> `"`), trim whitespace
      - INSERT IGNORE into verse_category_content: category_id (looked up from verse_categories by name), verse_reference, content_text (cleaned KJV), book
    - After all content rows inserted, for each verse, insert translations:
      - For each non-KJV translation in the grouped data (NIV, NRSV, NAB, NKJV, NLT):
        - Clean the text same way
        - INSERT IGNORE into verse_category_content_translations: verse_category_content_id (looked up), translation_code, translated_text, source='database'
      - Also insert KJV as a translation row (translation_code='KJV') so it appears in the translations list
    - Use batch inserts where possible (groups of 100)
    - Log progress every 500 verses: "Imported N/TOTAL verses..."

    **Phase 4: Upload CategoryPhotos.zip to B2**
    - Use `adm-zip` to read CategoryPhotos.zip (in project root)
    - If CategoryPhotos.zip not found, log warning and skip (don't fail)
    - For each entry in the zip:
      - Skip directories and non-image files (check extension: .jpg, .jpeg, .png, .webp)
      - Skip __MACOSX entries
      - Extract file buffer
      - Upload to B2 using PutObjectCommand (import from @aws-sdk/client-s3):
        - Key: `category-media/${filename}` (strip any directory prefix from zip path)
        - ContentType: image/jpeg or image/png based on extension
        - Bucket: process.env.B2_BUCKET_NAME
      - Build media_url: `${process.env.B2_CDN_URL || process.env.B2_ENDPOINT}/category-media/${filename}`
      - INSERT IGNORE into verse_category_media: category_id=NULL (shared), media_url, media_key
      - Add 50ms delay between uploads to avoid rate limiting
    - Log progress every 100 images: "Uploaded N/877 images..."

    **Phase 5: Summary**
    - Log total categories, verses, translations, and images imported
    - Log any failures (verse parse errors, upload failures) as warnings
    - Process exit 0

    **Key implementation details:**
    - Use mysql2/promise for DB connection (same as import-old-data.mjs)
    - Connection config from .env.local (DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASS)
    - Load .env.local using dotenv: `import dotenv from 'dotenv'; dotenv.config({ path: '.env.local' });`
    - B2 client config from B2_ENDPOINT, B2_KEY_ID, B2_APP_KEY, B2_BUCKET_NAME env vars
    - If B2 env vars not set, skip Phase 4 with warning
    - Script is idempotent: INSERT IGNORE ensures re-runs skip existing data
    - All SQL operations wrapped in try/catch with continue-on-error for individual rows

    **Run with:** `node scripts/import-verse-categories.mjs`
  </action>
  <verify>
    Run the import script: `node scripts/import-verse-categories.mjs`
    - Should complete without fatal errors
    - Check verse_categories: `SELECT COUNT(*) FROM verse_categories` should return 10
    - Check verse_category_content: `SELECT COUNT(*) FROM verse_category_content` should return ~3,500-4,000 rows
    - Check verse_category_content_translations: should have KJV + NIV (and other available translations) per verse
    - Check verse_category_media: should have ~877 rows (if B2 configured)
    - Re-running the script should be idempotent (no duplicates, same counts)
  </verify>
  <done>Import script successfully migrates all 10 categories, ~3,500+ unique verses with KJV base text and available translations, and uploads 877 images to B2. Script is resumable and idempotent.</done>
</task>

</tasks>

<verification>
- Script runs to completion: `node scripts/import-verse-categories.mjs`
- 10 categories in verse_categories table
- Verse count matches expected (~3,500+ unique verses)
- KJV translation present for all verses
- NIV and other old DB translations preserved
- CategoryPhotos uploaded to B2 (or skipped with warning if B2 not configured)
- Re-run produces no duplicates
</verification>

<success_criteria>
- All old DB versebycategory data migrated to new schema
- All CategoryPhotos.zip images uploaded and catalogued
- Script is idempotent and handles failures gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/11-verse-by-category-system/11-04-SUMMARY.md`
</output>
