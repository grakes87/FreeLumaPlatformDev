---
phase: 01-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/lib/auth/jwt.ts
  - src/lib/auth/password.ts
  - src/lib/auth/middleware.ts
  - src/lib/utils/api.ts
  - src/lib/utils/validation.ts
  - src/lib/utils/rate-limit.ts
  - src/app/api/auth/register/route.ts
  - src/app/api/auth/login/route.ts
  - src/app/api/auth/logout/route.ts
  - src/app/api/auth/me/route.ts
  - src/app/api/activation-codes/validate/route.ts
autonomous: true

must_haves:
  truths:
    - "User can register with email/password after validating an activation code"
    - "User can log in with correct credentials and receives JWT in HTTP-only cookie"
    - "User cannot log in with wrong password (returns 401)"
    - "Invalid or used activation codes are rejected"
    - "Rate limiting blocks excessive login attempts"
    - "GET /api/auth/me returns user data when JWT cookie is valid"
  artifacts:
    - path: "src/lib/auth/jwt.ts"
      provides: "JWT sign and verify with jose, cookie helpers"
      exports: ["signJWT", "verifyJWT", "setAuthCookie", "clearAuthCookie"]
    - path: "src/lib/auth/middleware.ts"
      provides: "withAuth wrapper for protected API routes"
      exports: ["withAuth"]
    - path: "src/app/api/auth/register/route.ts"
      provides: "POST registration with activation code, bcrypt, JWT"
      exports: ["POST"]
    - path: "src/app/api/auth/login/route.ts"
      provides: "POST login with bcrypt compare, rate limiting, JWT"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/auth/register/route.ts"
      to: "src/lib/db/models/User.ts"
      via: "User.create()"
      pattern: "User\\.create"
    - from: "src/app/api/auth/login/route.ts"
      to: "src/lib/auth/password.ts"
      via: "bcrypt compare"
      pattern: "comparePassword|bcrypt"
    - from: "src/app/api/auth/login/route.ts"
      to: "src/lib/auth/jwt.ts"
      via: "signs JWT and sets cookie"
      pattern: "signJWT|setAuthCookie"
    - from: "src/app/api/auth/me/route.ts"
      to: "src/lib/auth/middleware.ts"
      via: "withAuth wrapper"
      pattern: "withAuth"
---

<objective>
Build the complete email/password authentication system: JWT management, password hashing, registration with activation codes, login with rate limiting, logout, and auth middleware.

Purpose: Authentication is the gateway to the entire app. No feature can be properly built or tested without working auth. This plan creates the full auth infrastructure that all subsequent plans use.
Output: Working registration, login, logout, and session validation API endpoints with JWT cookies, bcrypt hashing, activation code enforcement, and rate limiting.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth library (JWT, password, middleware, validation, rate limiting)</name>
  <files>
    src/lib/auth/jwt.ts
    src/lib/auth/password.ts
    src/lib/auth/middleware.ts
    src/lib/utils/api.ts
    src/lib/utils/validation.ts
    src/lib/utils/rate-limit.ts
  </files>
  <action>
Create `src/lib/auth/jwt.ts`:
- Use jose library (NOT jsonwebtoken -- Edge runtime incompatible)
- `signJWT(payload: { id: number; email: string })`: Creates JWT with HS256, 30-day expiry (user stays logged in until explicit logout per CONTEXT.md)
- `verifyJWT(token: string)`: Returns decoded payload or null
- `setAuthCookie(token: string)`: Returns Set-Cookie header string for HTTP-only, Secure (skip Secure in dev), SameSite=Lax, Path=/, Max-Age=30 days
- `clearAuthCookie()`: Returns Set-Cookie header that expires the auth_token cookie
- Secret from process.env.JWT_SECRET encoded with TextEncoder

Create `src/lib/auth/password.ts`:
- Use bcryptjs (NOT bcrypt -- bcryptjs is pure JS, no native compilation)
- `hashPassword(password: string)`: Returns bcrypt hash using BCRYPT_ROUNDS from env
- `comparePassword(password: string, hash: string)`: Returns boolean
- Both functions are async

Create `src/lib/auth/middleware.ts`:
- `withAuth(handler)`: HOF wrapper for API routes
- Reads auth_token from cookies (using `cookies()` from next/headers)
- If no token: return 401 JSON
- If invalid token: return 401 JSON
- If valid: call handler with user data injected into a second parameter
- Type: handler receives (req: NextRequest, context: { params: Promise<any>; user: { id: number; email: string } })

Create `src/lib/utils/api.ts`:
- `successResponse(data, status = 200)`: Returns NextResponse.json with data
- `errorResponse(message, status = 400)`: Returns NextResponse.json with { error: message }
- `serverError(error, message = 'Internal server error')`: Logs error, returns 500

Create `src/lib/utils/validation.ts`:
- Shared Zod schemas for auth:
  - `registerSchema`: email (valid email), password (min 8 chars, at least one uppercase, one lowercase, one number), display_name (3-100 chars), username (3-30 chars, alphanumeric + underscores only, lowercase)
  - `loginSchema`: email (valid email), password (string non-empty)
  - `activationCodeSchema`: code (string, 12 chars)
- Export schemas and their inferred types

Create `src/lib/utils/rate-limit.ts`:
- Simple in-memory rate limiter using Map<string, { count: number; resetAt: number }>
- `rateLimit(identifier: string, limit: number, windowMs: number)`: Returns { success: boolean; remaining: number; resetAt: number }
- Clean up expired entries periodically (every 60s via setInterval)
- For login: 5 attempts per 15 minutes per email
- For registration: 3 attempts per hour per IP
- Returns appropriate headers (X-RateLimit-Remaining, X-RateLimit-Reset)
- NOTE: In-memory rate limiting is sufficient for single-server deployment. If scaling to multiple servers, switch to Redis.
  </action>
  <verify>
Write a quick test in the health endpoint or a temporary test route that:
1. Hashes a password and verifies it matches
2. Signs a JWT and verifies it decodes correctly
3. Validates a registration schema against valid and invalid inputs
4. Calls rateLimit() multiple times and confirms it blocks after the limit
  </verify>
  <done>JWT sign/verify with jose, bcrypt hash/compare, withAuth middleware, Zod validation schemas, in-memory rate limiter -- all working and tested.</done>
</task>

<task type="auto">
  <name>Task 2: Auth API endpoints (register, login, logout, me, activation code validate)</name>
  <files>
    src/app/api/auth/register/route.ts
    src/app/api/auth/login/route.ts
    src/app/api/auth/logout/route.ts
    src/app/api/auth/me/route.ts
    src/app/api/activation-codes/validate/route.ts
  </files>
  <action>
Create `src/app/api/activation-codes/validate/route.ts`:
- POST: Accepts { code: string }
- Validates code format with Zod
- Finds activation code in DB: WHERE code = :code AND used = false AND expires_at > NOW()
- If not found: return 400 { error: "Invalid or expired activation code" }
- If found: return 200 { valid: true, mode_hint: code.mode_hint }
- Does NOT mark the code as used yet (that happens during registration)

Create `src/app/api/auth/register/route.ts`:
- POST: Accepts { email, password, display_name, username, activation_code }
- Rate limit: 3 per hour per IP (use request headers x-forwarded-for or connection info)
- Validate input with registerSchema + activation code
- Check activation code validity (same query as validate, but in a transaction)
- Check email uniqueness (User.findOne where email)
- Check username uniqueness (User.findOne where username)
- Hash password with bcryptjs
- Generate random avatar_color from AVATAR_COLORS constant
- Create user in a database transaction:
  1. Create User record (onboarding_complete: false -- onboarding happens next)
  2. Atomically mark activation code as used: `UPDATE activation_codes SET used = true, used_by = :userId WHERE id = :codeId AND used = false` -- check affectedRows === 1 to prevent race condition
  3. Create UserSetting record with defaults
- If race condition (affectedRows === 0): rollback, return 409 "Activation code already used"
- Sign JWT with user id + email
- Return 201 with user data + Set-Cookie header for JWT
- Do NOT require email verification for access (per CONTEXT.md: full app access immediately)

Create `src/app/api/auth/login/route.ts`:
- POST: Accepts { email, password }
- Rate limit: 5 per 15 minutes per email address
- Validate with loginSchema
- Find user by email (include check for deleted_at IS NULL)
- If user not found: return 401 "Invalid email or password" (don't reveal which is wrong)
- Check if user is locked (locked_until > NOW()): return 429 "Account temporarily locked"
- Compare password with bcryptjs
- If wrong: increment failed_login_attempts, if >= 5 set locked_until to 30 minutes from now. Return 401.
- If correct: reset failed_login_attempts to 0, update last_login_at
- Sign JWT, set auth cookie
- Return 200 with user data

Create `src/app/api/auth/logout/route.ts`:
- POST: Clears auth_token cookie
- Returns 200 { message: "Logged out" }

Create `src/app/api/auth/me/route.ts`:
- GET: Protected with withAuth middleware
- Fetch full user record by ID from JWT payload
- Return user data (exclude password_hash)
- Include associated UserSetting
- This endpoint is called by AuthContext on app mount
  </action>
  <verify>
Test the complete auth flow with curl:
```bash
# 1. Validate activation code (get a code from the seeder)
CODE=$(mysql -u root -N -e "SELECT code FROM freeluma_dev.activation_codes WHERE used=0 LIMIT 1;")
curl -X POST http://localhost:3000/api/activation-codes/validate -H "Content-Type: application/json" -d "{\"code\":\"$CODE\"}"
# Expected: {"valid":true,"mode_hint":null}

# 2. Register
curl -v -X POST http://localhost:3000/api/auth/register -H "Content-Type: application/json" -d "{\"email\":\"test@example.com\",\"password\":\"TestPass123\",\"display_name\":\"Test User\",\"username\":\"testuser\",\"activation_code\":\"$CODE\"}"
# Expected: 201 with Set-Cookie header and user data

# 3. Login
curl -v -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d "{\"email\":\"test@example.com\",\"password\":\"TestPass123\"}"
# Expected: 200 with Set-Cookie and user data

# 4. Get current user (use cookie from login response)
curl http://localhost:3000/api/auth/me -H "Cookie: auth_token=<token_from_login>"
# Expected: 200 with user data

# 5. Wrong password (repeat 5+ times)
for i in $(seq 1 6); do curl -s -o /dev/null -w "%{http_code}\n" -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"wrong"}'; done
# Expected: 401, 401, 401, 401, 401, then 429 (locked)

# 6. Logout
curl -v -X POST http://localhost:3000/api/auth/logout -H "Cookie: auth_token=<token>"
# Expected: 200 with Set-Cookie clearing the token

# 7. Verify activation code is marked used
mysql -u root -e "SELECT code, used, used_by FROM freeluma_dev.activation_codes WHERE code='$CODE';"
# Expected: used=1, used_by=<user_id>
```
  </verify>
  <done>Complete email/password auth: register with activation code (atomic, race-condition safe), login with rate limiting and account locking, logout, and session validation via /api/auth/me.</done>
</task>

</tasks>

<verification>
1. Registration creates user with hashed password (not plaintext) and marks activation code as used
2. Login returns JWT in HTTP-only cookie
3. /api/auth/me returns user data with valid cookie, 401 without
4. Rate limiting blocks after 5 failed login attempts per email
5. Account locks after 5 consecutive failed attempts
6. Duplicate email or username returns 409
7. Used activation code returns 400
8. Build succeeds
</verification>

<success_criteria>
- JWT auth via jose (30-day expiry, HTTP-only cookie)
- bcryptjs password hashing (12 rounds)
- Activation code validation with atomic marking (race-condition safe)
- Rate limiting: 5 login attempts per 15 min, 3 registrations per hour
- Account locking after 5 failed attempts (30 min lock)
- withAuth middleware protecting /api/auth/me
- Zod validation on all inputs
- All endpoints return proper error messages and status codes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
