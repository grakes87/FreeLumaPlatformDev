---
phase: 04-enhanced-content
plan: 06
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - src/lib/auth/middleware.ts
  - src/app/api/account/deactivate/route.ts
  - src/app/api/account/delete/route.ts
  - src/app/api/auth/login/route.ts
  - src/lib/cron/accountCleanup.ts
  - server.js
autonomous: true

must_haves:
  truths:
    - "Banned users receive 403 with suspension message when calling any authenticated API"
    - "withModerator middleware allows both admin and moderator roles"
    - "User can deactivate account (instant, reversible on re-login)"
    - "User can request deletion (30-day grace period, reversible on re-login)"
    - "Re-login during grace period or deactivation restores active status"
    - "Cron job permanently deletes accounts after 30-day grace period"
  artifacts:
    - path: "src/lib/auth/middleware.ts"
      provides: "Extended withAuth with ban check, new withModerator middleware"
      exports: ["withAuth", "withAdmin", "withModerator", "withOptionalAuth"]
    - path: "src/app/api/account/deactivate/route.ts"
      provides: "POST endpoint for account deactivation"
      exports: ["POST"]
    - path: "src/app/api/account/delete/route.ts"
      provides: "POST endpoint for account deletion request"
      exports: ["POST"]
    - path: "src/lib/cron/accountCleanup.ts"
      provides: "Cron job for permanent deletion after 30 days"
      contains: "cron.schedule"
  key_links:
    - from: "src/lib/auth/middleware.ts"
      to: "User model status field"
      via: "Ban check in withAuth"
      pattern: "status.*banned|Ban\\.findOne"
    - from: "src/app/api/auth/login/route.ts"
      to: "User.status"
      via: "Auto-reactivate on login for deactivated/pending_deletion"
      pattern: "status.*deactivated|pending_deletion.*active"
---

<objective>
Build ban enforcement middleware, moderator role support, and account lifecycle management — deactivation, deletion with 30-day grace period, and auto-reactivation on login.

Purpose: Enforces bans across all API routes, enables moderator role access, and lets users manage account status (deactivate or delete).
Output: Extended auth middleware, account deactivate/delete APIs, login auto-reactivation, 30-day cleanup cron job.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-enhanced-content/04-RESEARCH.md
@.planning/phases/04-enhanced-content/04-02-SUMMARY.md

Follow existing patterns:
@src/lib/auth/middleware.ts (withAuth, withAdmin to extend)
@src/app/api/auth/login/route.ts (login flow to extend with status check)
@server.js (for cron job initialization pattern — see scheduler init)
@src/lib/email/scheduler.ts (for existing cron pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ban enforcement in withAuth + withModerator middleware</name>
  <files>src/lib/auth/middleware.ts</files>
  <action>
    Extend withAuth to check user ban status AFTER JWT verification:
    1. After verifyJWT succeeds, do a lightweight DB check: User.findByPk(user.id, { attributes: ['id', 'status'] })
    2. If status === 'banned':
       - Check the user's active ban: Ban.findOne({ where: { user_id: user.id, lifted_at: null }, order: [['created_at', 'DESC']] })
       - If ban exists and (expires_at is null OR expires_at > now): return 403 with { error: 'Account suspended', reason: ban.reason, expires_at: ban.expires_at }
       - If ban exists and expires_at <= now: auto-unban (set user.status = 'active', ban.lifted_at = now) and continue
       - If no active ban found: set user.status = 'active' (cleanup) and continue
    3. If status === 'deactivated' or 'pending_deletion': return 403 with { error: 'Account inactive', status: user.status }
       - NOTE: This 403 for deactivated/pending_deletion is for API calls EXCEPT login. The login route handles reactivation separately.

    IMPORTANT: The ban check adds a DB query to every authenticated request. Per research, this is acceptable for the expected scale. Use User.findByPk which is indexed on PK and fast.

    IMPORTANT: Import Ban model lazily (same pattern as withAdmin lazy-imports User) to avoid circular dependencies.

    Add withModerator middleware (new):
    ```
    export function withModerator(handler: AuthHandler) {
      return withAuth(async (req, context) => {
        const { User } = await import('@/lib/db/models');
        const dbUser = await User.findByPk(context.user.id, {
          attributes: ['id', 'is_admin', 'role'],
        });
        if (!dbUser || (!dbUser.is_admin && dbUser.role !== 'moderator')) {
          return NextResponse.json({ error: 'Forbidden: moderator access required' }, { status: 403 });
        }
        return handler(req, { ...context, isAdmin: dbUser.is_admin } as any);
      });
    }
    ```
  </action>
  <verify>Test ban enforcement: set a user status to 'banned' in DB, call any withAuth endpoint → 403 with suspension message. Test withModerator: non-moderator gets 403, moderator gets through.</verify>
  <done>withAuth blocks banned users with expiry message, auto-unbans expired bans. withModerator allows admin+moderator roles.</done>
</task>

<task type="auto">
  <name>Task 2: Account deactivate + delete APIs</name>
  <files>
    src/app/api/account/deactivate/route.ts
    src/app/api/account/delete/route.ts
  </files>
  <action>
    Create POST /api/account/deactivate (withAuth):
    1. No body needed (confirm dialog handled on frontend)
    2. Fetch user, set status = 'deactivated', deactivated_at = new Date()
    3. Clear auth cookie (log the user out)
    4. Return 200 { message: "Account deactivated" }

    Create POST /api/account/delete (withAuth):
    1. Validate with Zod: { password: string() } (require password confirmation for permanent action)
    2. Verify password matches (401 if wrong). If OAuth-only user (no password), accept without password.
    3. Set status = 'pending_deletion', deletion_requested_at = new Date()
    4. Send email: "Your account is scheduled for deletion in 30 days. Log in to cancel."
    5. Clear auth cookie
    6. Return 200 { message: "Account scheduled for deletion in 30 days", deletion_date: 30 days from now }
  </action>
  <verify>POST /api/account/deactivate sets status and clears cookie. POST /api/account/delete sets pending_deletion and sends email.</verify>
  <done>Deactivation is instant and reversible. Deletion starts 30-day countdown with email notification.</done>
</task>

<task type="auto">
  <name>Task 3: Login auto-reactivation + deletion cleanup cron job</name>
  <files>
    src/app/api/auth/login/route.ts
    src/lib/cron/accountCleanup.ts
    server.js
  </files>
  <action>
    Extend POST /api/auth/login:
    After password verification succeeds, check user.status before issuing JWT:
    - 'active': proceed normally
    - 'deactivated': auto-reactivate → set status='active', deactivated_at=null, continue login
    - 'pending_deletion': cancel deletion → set status='active', deletion_requested_at=null, continue login
    - 'banned': check Ban record → if expired, auto-unban and continue; if active, return 403 with { error: 'Account suspended', reason, expires_at }

    Also extend the Google/Apple OAuth login routes similarly (check existing /api/auth/google/route.ts and /api/auth/apple/route.ts). After find-or-create, check status and auto-reactivate if deactivated/pending_deletion.

    Create src/lib/cron/accountCleanup.ts:
    - Schedule: daily at 3am UTC — cron.schedule('0 3 * * *', ...)
    - Find all users where status='pending_deletion' AND deletion_requested_at < 30 days ago
    - For each user:
      1. Anonymize content: Update all their Posts set user_id to a sentinel "Deleted User" account (use id=0 or create a dedicated deleted_user record). Use Post.update({ user_id: DELETED_USER_ID }, { where: { user_id: user.id } })
      2. Similarly anonymize PostComments, DailyComments, DailyReactions
      3. Hard-delete user: user.destroy({ force: true }) — this cascades to user_categories, user_settings, follows, blocks, etc. via FK CASCADE
    - Log each permanent deletion
    - Use globalThis guard to prevent double-init (same pattern as email scheduler)

    Initialize in server.js:
    - Import and call the cleanup function after server starts (same 5s setTimeout pattern as email scheduler)
    - Guard with globalThis.__accountCleanupReady
  </action>
  <verify>Test: set user status to 'deactivated' in DB, login succeeds and status becomes 'active'. Set deletion_requested_at to 31 days ago with status='pending_deletion', trigger cron → user is permanently deleted.</verify>
  <done>Login auto-reactivates deactivated/pending_deletion users. Cron job permanently deletes after 30 days with content anonymization.</done>
</task>

</tasks>

<verification>
1. Banned user gets 403 with reason and expiry on any authenticated endpoint
2. Expired ban auto-lifts on next request
3. withModerator allows admin and moderator roles, blocks regular users
4. POST /api/account/deactivate sets status and clears cookie
5. POST /api/account/delete sets pending_deletion with password confirmation
6. Login auto-reactivates deactivated and pending_deletion users
7. Cron job deletes users after 30 days and anonymizes their content
</verification>

<success_criteria>
- Ban enforcement works in withAuth with auto-unban for expired bans
- withModerator middleware allows admin + moderator roles
- Account deactivation is instant and reversible on re-login
- Account deletion has 30-day grace period, cancelable by logging in
- Cron job permanently deletes accounts and anonymizes content after 30 days
- All OAuth login routes also handle status checks
</success_criteria>

<output>
After completion, create `.planning/phases/04-enhanced-content/04-06-SUMMARY.md`
</output>
