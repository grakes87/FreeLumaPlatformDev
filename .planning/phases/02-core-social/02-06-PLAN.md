---
phase: 02-core-social
plan: 06
type: execute
wave: 3
depends_on: [02-02, 02-03]
files_modified:
  - src/app/api/posts/route.ts
  - src/hooks/useFeed.ts
  - src/hooks/useInfiniteScroll.ts
autonomous: true

must_haves:
  truths:
    - "User can view chronological feed of posts from followed users"
    - "Feed supports cursor-based infinite scroll"
    - "Feed can be filtered by category"
    - "Feed can be sorted by newest or most engaged"
    - "Blocked users' posts are excluded from feed"
    - "User's own posts appear in their feed"
  artifacts:
    - path: "src/app/api/posts/route.ts"
      provides: "GET feed endpoint with cursor pagination, filters, sort"
      exports: ["GET", "POST"]
    - path: "src/hooks/useFeed.ts"
      provides: "Feed data fetching with cursor pagination"
      exports: ["useFeed"]
    - path: "src/hooks/useInfiniteScroll.ts"
      provides: "Generic infinite scroll hook wrapping useInView"
      exports: ["useInfiniteScroll"]
  key_links:
    - from: "src/hooks/useFeed.ts"
      to: "/api/posts"
      via: "fetch GET with cursor/filter/sort params"
      pattern: "fetch.*api/posts"
    - from: "src/hooks/useInfiniteScroll.ts"
      to: "react-intersection-observer"
      via: "useInView hook"
      pattern: "useInView"
---

<objective>
Add the GET feed endpoint to the posts API route, create the useFeed hook for feed data management with cursor pagination, and create a generic useInfiniteScroll hook using react-intersection-observer.

Purpose: The feed is the central feature of Phase 2 — it's the main screen users see. Cursor-based pagination ensures stable scroll behavior. The infinite scroll hook is reusable for prayer wall, category feeds, and bookmark lists.
Output: 1 API route update (add GET handler), 2 hooks.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-social/02-RESEARCH.md
@.planning/phases/02-core-social/02-02-SUMMARY.md
@.planning/phases/02-core-social/02-03-SUMMARY.md

@src/app/api/posts/route.ts
@src/lib/utils/blocks.ts
@src/lib/db/models/index.ts
@src/lib/auth/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GET feed endpoint to posts API route</name>
  <files>src/app/api/posts/route.ts</files>
  <action>
    Add a GET handler to the existing src/app/api/posts/route.ts (which already has POST from 02-02).

    GET: withAuth. Query params:
    - cursor (string, optional) — Base64url-encoded JSON of { created_at, id }
    - limit (number, default 20, max 50)
    - category (string, optional) — category slug to filter by, 'all' or empty means no filter
    - sort (string, default 'newest') — 'newest' or 'engaged'
    - feed_type (string, default 'following') — 'following' (posts from followed users + self), 'all' (all public posts)

    Implementation:
    1. Decode cursor if provided using decodeCursor helper (Base64url -> JSON parse -> { created_at, id }).
    2. Get blocked user IDs with getBlockedUserIds(userId).
    3. Get followed user IDs from Follow table (follower_id = currentUser), plus currentUser's own ID.
    4. Build WHERE clause:
       - If feed_type='following': user_id IN followedIds (and NOT IN blockedIds)
       - If feed_type='all': visibility='public' and user_id NOT IN blockedIds
       - If category provided and not 'all': join or filter by Category slug
       - If cursor: add compound cursor condition `(created_at < cursor.created_at) OR (created_at = cursor.created_at AND id < cursor.id)`
    5. Build ORDER:
       - If sort='newest': [created_at DESC, id DESC]
       - If sort='engaged': Add subquery for engagement score (reaction_count + comment_count), order by score DESC then created_at DESC
    6. Query Post.findAll with:
       - include: User as 'author' (id, username, display_name, avatar_url), Category as 'category' (id, name, slug)
       - attributes: include subqueries for reaction_count, comment_count
       - limit: limit + 1 (fetch one extra to determine hasMore)
       - Sequelize paranoid:true already excludes soft-deleted posts
    7. Determine hasMore, pop extra, encodeCursor for last item.
    8. For each post in results, batch-query user's reaction (PostReaction where user_id and post_id IN), user's bookmark status (Bookmark where user_id and post_id IN). Attach user_reaction and is_bookmarked to each post response.
    9. Return { posts, next_cursor, has_more }.

    Add helper functions at top of file:
    - `decodeCursor(cursor: string): { created_at: string; id: number } | null`
    - `encodeCursor(post: { created_at: Date; id: number }): string`
  </action>
  <verify>
    curl GET /api/posts — returns paginated feed with posts, next_cursor, has_more.
    curl GET /api/posts?category=prayer-requests — filters by category.
    curl GET /api/posts?sort=engaged — sorts by engagement.
    curl GET /api/posts?cursor=<encoded> — returns next page.
  </verify>
  <done>Feed API returns cursor-paginated posts with category filter, sort options, block exclusion, and user-specific reaction/bookmark status.</done>
</task>

<task type="auto">
  <name>Task 2: Create useInfiniteScroll and useFeed hooks</name>
  <files>
    src/hooks/useInfiniteScroll.ts
    src/hooks/useFeed.ts
  </files>
  <action>
    **src/hooks/useInfiniteScroll.ts:**
    Generic reusable hook using react-intersection-observer's useInView. Takes: { onLoadMore: () => void, hasMore: boolean, loading: boolean }. Returns: { ref } (the ref to attach to the sentinel div). When sentinel enters viewport (inView becomes true) and hasMore is true and loading is false, calls onLoadMore. Uses useEffect to trigger. The ref from useInView({ threshold: 0 }) is returned for the consumer to attach to a sentinel element at the bottom of the list.

    **src/hooks/useFeed.ts:**
    Hook for feed data. Takes: { category?: string, sort?: string, feedType?: string }. Manages state: posts (array), nextCursor (string|null), hasMore (boolean), loading (boolean), initialLoading (boolean). On mount and when filters change, fetches first page (cursor=null). Exposes fetchNextPage() that fetches with current nextCursor. When filters change, resets posts array and cursor, fetches fresh. Returns { posts, hasMore, loading, initialLoading, fetchNextPage, refresh }. refresh() resets and re-fetches from beginning.
  </action>
  <verify>
    npm run build — no TypeScript errors.
    Verify useFeed fetches from /api/posts and returns posts array.
  </verify>
  <done>useInfiniteScroll provides reusable viewport-triggered loading. useFeed manages feed state with cursor pagination and filter changes.</done>
</task>

</tasks>

<verification>
1. GET /api/posts returns first page of posts from followed users
2. Cursor pagination returns correct subsequent pages with no duplicates or gaps
3. Category filter narrows results correctly
4. Sort by engaged returns most-reacted posts first
5. Blocked users' posts excluded from all results
6. Each post includes user_reaction and is_bookmarked for current user
7. useFeed resets and re-fetches when filters change
8. useInfiniteScroll triggers onLoadMore when sentinel enters viewport
</verification>

<success_criteria>
- Feed API handles all filter/sort/cursor combinations correctly
- Cursor-based pagination stable under concurrent writes
- Block filtering applied universally
- useFeed manages state correctly including filter resets
- useInfiniteScroll is generic and reusable for other list pages
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-social/02-06-SUMMARY.md`
</output>
