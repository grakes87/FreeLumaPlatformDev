---
phase: 02-core-social
plan: 06
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src/app/api/feed/route.ts
  - src/app/api/feed/fyp/route.ts
  - src/hooks/useFeed.ts
  - src/hooks/useInfiniteScroll.ts
autonomous: true

must_haves:
  truths:
    - "User can fetch a paginated feed of posts from followed users (Following tab)"
    - "User can fetch a FYP feed with recommendation algorithm (For You tab)"
    - "Feed uses cursor-based pagination (no offset)"
    - "Feed excludes posts from blocked users and soft-deleted posts"
    - "Feed respects mode isolation when enabled"
    - "Feed respects post visibility (public vs followers-only)"
    - "Infinite scroll triggers next page load when sentinel enters viewport"
    - "Pull-to-refresh resets feed to latest content"
  artifacts:
    - path: "src/app/api/feed/route.ts"
      provides: "GET Following feed with cursor pagination"
      exports: ["GET"]
    - path: "src/app/api/feed/fyp/route.ts"
      provides: "GET FYP feed with recommendation algorithm"
      exports: ["GET"]
    - path: "src/hooks/useFeed.ts"
      provides: "Feed state management with cursor pagination and tab switching"
      exports: ["useFeed"]
    - path: "src/hooks/useInfiniteScroll.ts"
      provides: "Generic infinite scroll hook wrapping useInView"
      exports: ["useInfiniteScroll"]
  key_links:
    - from: "src/hooks/useFeed.ts"
      to: "src/app/api/feed/route.ts"
      via: "fetch /api/feed or /api/feed/fyp"
      pattern: "api/feed"
    - from: "src/hooks/useInfiniteScroll.ts"
      to: "react-intersection-observer"
      via: "useInView hook"
      pattern: "useInView"
---

<objective>
Build the feed API endpoints (Following + FYP) with cursor-based pagination, block/mode filtering, and the client-side hooks for infinite scroll and feed state management.

Purpose: The feed is the central content consumption surface. It needs two modes (FYP and Following), cursor-based pagination for stable browsing, and proper filtering for blocks, mode isolation, and visibility.
Output: 2 API routes, 2 hooks.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/02-core-social/02-CONTEXT.md
@.planning/phases/02-core-social/02-RESEARCH.md
@.planning/phases/02-core-social/02-02-SUMMARY.md
@.planning/phases/02-core-social/02-03-SUMMARY.md
@src/lib/utils/cursor.ts
@src/lib/utils/blocks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create feed API routes (Following + FYP)</name>
  <files>
    src/app/api/feed/route.ts
    src/app/api/feed/fyp/route.ts
  </files>
  <action>
    **src/app/api/feed/route.ts — GET (Following feed):**
    - withAuth
    - Query params: cursor (optional), limit (default 20, max 50)
    - Get user's followed user IDs (Follow WHERE follower_id = userId AND status = 'active')
    - Add userId to the list (include own posts)
    - Get blocked user IDs via getBlockedUserIds
    - Build WHERE:
      - user_id IN followedIds AND user_id NOT IN blockedIds
      - post_type = 'text' (exclude prayer_request type from main feed — those are prayer wall only, per CONTEXT "completely separate content streams")
      - deleted_at IS NULL (paranoid default handles this)
      - Visibility check: 'public' OR (visibility='followers' AND user_id IN followedIds)
      - Mode isolation: if PlatformSetting 'mode_isolation_social' = 'true', filter by mode = user's mode
    - Apply cursor pagination using decodeCursor/encodeCursor
    - Order by created_at DESC, id DESC
    - Include for each post:
      - Author (User: id, username, display_name, avatar_url)
      - Media (PostMedia: ordered by sort_order)
      - Subquery counts: reaction_count, comment_count, repost_count
      - User's own reaction (subquery or batch lookup)
      - User's bookmark status (subquery or batch lookup)
      - Repost info: if post is a quote repost, include the embedded original post with its author
    - Batch lookup approach for user-specific data (reaction, bookmark): After fetching post IDs, run separate queries for PostReaction WHERE user_id AND post_id IN (...), Bookmark WHERE user_id AND post_id IN (...)
    - Return { posts, next_cursor, has_more }

    **src/app/api/feed/fyp/route.ts — GET (For You Page feed):**
    - withAuth
    - Query params: cursor (optional), limit (default 20, max 50)
    - FYP algorithm (Claude's discretion per CONTEXT):
      - Start with all public, non-deleted posts (filtered by mode isolation if enabled)
      - Exclude blocked users
      - Score each post using signals:
        - Recency: exponential decay — newer posts score higher. `recency_score = 1 / (1 + hours_since_post / 24)`
        - Engagement: `engagement_score = (reaction_count * 1 + comment_count * 2 + repost_count * 3) / max_engagement` normalized
        - Author relationship: +0.3 if followed by user, +0.1 if followed by someone user follows
        - Category match: +0.2 if post author shares categories with user (from user_categories)
        - Interaction history: +0.2 if user has previously reacted/commented on this author's posts
      - Combined score: `0.4 * recency + 0.3 * engagement + 0.2 * relationship + 0.1 * category_match`
      - For efficiency: Use SQL-computed scores where possible. Fallback to application-level sorting for the relationship/interaction signals.
      - Practical approach: Fetch candidate pool (last 7 days of public posts, limit 200), score in application code, return top N.
    - Same includes as Following feed (author, media, counts, user reaction, bookmark)
    - Cursor-based pagination: use score + id as compound cursor instead of created_at + id
    - Return { posts, next_cursor, has_more }

    **Important:** Both endpoints MUST handle the case where a post is a quote repost (has a row in reposts table where quote_post_id = post.id). For reposts, include the original post data inline: `original_post: { id, body, author: {...}, media: [...] }`.
  </action>
  <verify>
    - `npm run build` passes
    - Following feed returns only posts from followed users (not prayer requests)
    - FYP feed returns scored posts with engagement weighting
    - Cursor pagination works correctly (no duplicates across pages)
    - Blocked users excluded from both feeds
    - Mode isolation filters when enabled
  </verify>
  <done>Feed APIs work: Following feed shows followed users' posts with cursor pagination; FYP feed shows scored public posts with recommendation algorithm. Both exclude blocks, respect mode isolation, include enriched post data.</done>
</task>

<task type="auto">
  <name>Task 2: Create useFeed hook and useInfiniteScroll hook</name>
  <files>
    src/hooks/useFeed.ts
    src/hooks/useInfiniteScroll.ts
  </files>
  <action>
    **src/hooks/useInfiniteScroll.ts:**
    - Generic hook wrapping react-intersection-observer's useInView
    - Hook: `useInfiniteScroll(options?: { threshold?: number; rootMargin?: string })`
    - Uses useInView({ threshold: 0, rootMargin: '200px', ...options })
    - Returns { ref (to attach to sentinel div), inView (boolean) }
    - Consumers use inView in a useEffect to trigger loadMore

    **src/hooks/useFeed.ts:**
    - Hook: `useFeed()`
    - State:
      - activeTab: 'fyp' | 'following' (default 'fyp' per CONTEXT)
      - posts: array of enriched post objects
      - loading: boolean
      - refreshing: boolean
      - hasMore: boolean
      - cursor: string | null
    - On mount and tab change: reset posts and cursor, fetch first page
    - `fetchNextPage()`: append next page of posts using cursor. Only callable when !loading && hasMore.
    - `refresh()`: reset cursor and posts, fetch fresh first page (for pull-to-refresh)
    - `setActiveTab(tab)`: switch between 'fyp' and 'following', triggers reset + fresh fetch
    - `removePost(postId)`: remove a post from the local list (for after delete)
    - `updatePost(postId, updates)`: update a post in the local list (for after edit)
    - API calls: GET /api/feed/fyp for FYP tab, GET /api/feed for Following tab
    - Return { posts, loading, refreshing, hasMore, activeTab, fetchNextPage, refresh, setActiveTab, removePost, updatePost }
  </action>
  <verify>
    - `npm run build` passes
    - useFeed hook fetches and paginates correctly
    - Tab switching resets state and fetches from correct endpoint
    - useInfiniteScroll returns ref and inView
  </verify>
  <done>useFeed hook manages FYP/Following tab state with cursor pagination, refresh, and local state updates. useInfiniteScroll provides generic IntersectionObserver-based trigger for infinite scroll.</done>
</task>

</tasks>

<verification>
- Following feed returns only followed users' posts
- FYP feed returns engagement-weighted posts
- Cursor pagination stable under concurrent writes
- No duplicates across pages
- Blocked users excluded
- Mode isolation works when enabled
- Infinite scroll hook triggers page load
- Tab switching resets and re-fetches
</verification>

<success_criteria>
- Two feed modes (FYP + Following) with different APIs
- FYP recommendation algorithm with engagement + recency + relationship signals
- Cursor-based pagination on all feeds
- Block and mode isolation filtering
- Reusable infinite scroll hook
- Feed hook with tab switching and pull-to-refresh
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-social/02-06-SUMMARY.md`
</output>
