---
phase: 03-real-time
plan: 05
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/lib/socket/chat.ts
  - src/lib/socket/index.ts
autonomous: true

must_haves:
  truths:
    - "Socket.IO /chat namespace delivers real-time messages to conversation room members"
    - "Typing indicators broadcast to conversation room via volatile events"
    - "Read receipts batched per conversation (single event, not per-message)"
    - "Conversation room joins verified against DB participation"
    - "Presence changes (online/offline) broadcast to relevant users"
  artifacts:
    - path: "src/lib/socket/chat.ts"
      provides: "Chat namespace event handlers"
      exports: ["registerChatHandlers"]
  key_links:
    - from: "src/lib/socket/chat.ts"
      to: "src/lib/db/models"
      via: "ConversationParticipant lookup for room join auth"
      pattern: "ConversationParticipant\\.findOne"
    - from: "src/lib/socket/chat.ts"
      to: "src/lib/socket/presence.ts"
      via: "presenceManager for online status broadcasts"
      pattern: "presenceManager"
---

<objective>
Implement Socket.IO /chat namespace event handlers: conversation room management with authorization, typing indicators with volatile emits, read receipt broadcasting, and online presence change notifications.

Purpose: Enable real-time message delivery, typing indicators, and presence tracking that make the chat feel instant.
Output: Chat handler file with all real-time event logic.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-real-time/03-RESEARCH.md (Patterns 3, 6, Pitfalls 2-4)
@.planning/phases/03-real-time/03-01-SUMMARY.md
@.planning/phases/03-real-time/03-02-SUMMARY.md
@src/lib/socket/index.ts
@src/lib/socket/presence.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat namespace handlers</name>
  <files>
    src/lib/socket/chat.ts
  </files>
  <action>
    Create `src/lib/socket/chat.ts` with `registerChatHandlers(nsp, socket)`:

    **conversation:join** event:
    - Receives { conversationId: number }
    - Verify user is participant: query ConversationParticipant where conversation_id AND user_id AND deleted_at IS NULL
    - If not participant, silently ignore (security: don't leak existence)
    - socket.join(`conv:${conversationId}`)
    - Broadcast presence to room: emit "presence:online" to conv room with userId

    **conversation:leave** event:
    - socket.leave(`conv:${conversationId}`)

    **typing:start** event:
    - Receives { conversationId: number }
    - Broadcast via volatile (droppable): socket.to(`conv:${conversationId}`).volatile.emit("typing:start", { userId: socket.data.userId })

    **typing:stop** event:
    - Same pattern as typing:start but emits "typing:stop"

    **conversation:read** event:
    - Receives { conversationId: number }
    - Batch update: set last_read_at on ConversationParticipant to now
    - For 1:1 conversations: update MessageStatus to 'read' for all unread messages from other sender
    - Emit "messages:read" to conversation room with { userId: socket.data.userId, readAt: timestamp }
    - This is the batch read receipt pattern from Pitfall 4

    **message:react** event:
    - Receives { messageId: number, reactionType: string }
    - Note: reaction persistence happens via API route (03-04); this socket event just broadcasts the real-time update
    - Broadcast to conversation room: "message:reaction" with { messageId, userId, reactionType }

    **On disconnect:**
    - presenceManager.removeSocket(socket.data.userId, socket.id)
    - If user has no more sockets (fully offline):
      - Get user's conversations (query ConversationParticipant)
      - Emit "presence:offline" to each conversation room with { userId }

    **On connect (already in index.ts, but enhance):**
    - presenceManager.addUser(socket.data.userId, socket.id)
    - Auto-join all active conversation rooms (query ConversationParticipant where user_id AND deleted_at IS NULL)
    - Emit "presence:online" to all conversation rooms
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - registerChatHandlers exported
    - All event handlers use proper room targeting (not broadcasting to all)
    - Typing events use volatile emits
    - Conversation join verifies DB participation
  </verify>
  <done>Chat namespace handles real-time message delivery, typing indicators, batch read receipts, and presence tracking</done>
</task>

<task type="auto">
  <name>Task 2: Wire chat handlers into Socket.IO initialization</name>
  <files>
    src/lib/socket/index.ts
  </files>
  <action>
    Update `src/lib/socket/index.ts`:
    - Import registerChatHandlers from "./chat"
    - In the /chat namespace connection handler, call registerChatHandlers(chatNsp, socket)
    - Ensure presenceManager.addUser is called on connect and presenceManager.removeSocket on disconnect
    - The namespace setup should happen in the setupNamespaces() or lazy-init function:
      ```typescript
      chatNsp.on("connection", (socket) => {
        registerChatHandlers(chatNsp, socket);
        presenceManager.addUser(socket.data.userId, socket.id);
        socket.on("disconnect", () => {
          presenceManager.removeSocket(socket.data.userId, socket.id);
        });
      });
      ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Chat handlers registered on /chat namespace connection
  </verify>
  <done>Socket.IO /chat namespace fully wired with chat handlers, presence tracking on connect/disconnect</done>
</task>

</tasks>

<verification>
- Chat handlers compile without errors
- registerChatHandlers properly imported and called in index.ts
- Conversation room joins check DB participation
- Typing indicators use volatile emits
- Read receipts batch-update (not per-message)
- Presence broadcasts to conversation rooms
</verification>

<success_criteria>
Real-time chat transport operational: messages delivered to correct rooms, typing indicators work, read receipts batch properly, and online/offline status broadcasts to relevant conversations.
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time/03-05-SUMMARY.md`
</output>
