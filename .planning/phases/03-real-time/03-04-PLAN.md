---
phase: 03-real-time
plan: 04
type: execute
wave: 2
depends_on: ["03-02", "03-03"]
files_modified:
  - src/app/api/chat/conversations/route.ts
  - src/app/api/chat/conversations/[id]/route.ts
  - src/app/api/chat/conversations/[id]/messages/route.ts
  - src/app/api/chat/conversations/[id]/participants/route.ts
  - src/app/api/chat/requests/route.ts
  - src/app/api/upload/chat-media/route.ts
autonomous: true

must_haves:
  truths:
    - "User can GET their conversation list sorted by last_message_at with unread counts"
    - "User can POST to create a new 1:1 or group conversation"
    - "User can GET paginated messages for a conversation they participate in"
    - "User can POST a message (text, media, voice, shared_post) to a conversation"
    - "User can GET/accept/decline message requests"
    - "Messaging access rules (everyone/followers/mutual/nobody) are enforced on conversation creation"
    - "Chat media upload returns presigned URL for B2"
  artifacts:
    - path: "src/app/api/chat/conversations/route.ts"
      provides: "Conversation list GET and create POST"
      exports: ["GET", "POST"]
    - path: "src/app/api/chat/conversations/[id]/messages/route.ts"
      provides: "Message list GET and send POST"
      exports: ["GET", "POST"]
    - path: "src/app/api/chat/requests/route.ts"
      provides: "Message request management"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/chat/conversations/[id]/messages/route.ts"
      to: "src/lib/socket/index.ts"
      via: "getIO() to emit message:new after DB persist"
      pattern: "getIO.*emit"
    - from: "src/app/api/chat/conversations/route.ts"
      to: "src/lib/db/models"
      via: "Conversation, ConversationParticipant queries"
      pattern: "Conversation\\.findAll"
---

<objective>
Create all chat REST API routes: conversation CRUD, message CRUD with cursor pagination, participant management, message requests, and chat media upload. API routes handle all business logic and persist to DB, then emit Socket.IO events for real-time delivery.

Purpose: Provide the HTTP API layer for all chat operations (Socket.IO only handles real-time delivery, not persistence).
Output: 6 API route files covering full chat CRUD.

**Scope note:** This plan is large (6 API files with significant business logic). The routes are tightly coupled (conversations, messages, participants, requests all share models and access rules) so splitting would create artificial boundaries. The two tasks are cleanly divided: Task 1 = conversation CRUD, Task 2 = message CRUD + supporting routes. Executor should take breaks between tasks.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-real-time/03-RESEARCH.md
@.planning/phases/03-real-time/03-CONTEXT.md (messaging access rules, message management decisions)
@src/lib/utils/api.ts (withAuth pattern)
@src/lib/utils/cursor.ts (cursor pagination pattern)
@src/lib/storage/presign.ts (presigned URL pattern)
@src/lib/moderation/profanity.ts (profanity filter)
@.planning/phases/03-real-time/03-02-SUMMARY.md
@.planning/phases/03-real-time/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Conversation list and creation API</name>
  <files>
    src/app/api/chat/conversations/route.ts
    src/app/api/chat/conversations/[id]/route.ts
  </files>
  <action>
    **GET /api/chat/conversations** (withAuth):
    - Fetch all conversations where user is a participant (deleted_at IS NULL on participant)
    - Include: last message preview (content truncated to 100 chars, sender display_name for groups)
    - Include: other participant(s) info (display_name, username, avatar_url, avatar_color) for direct convos
    - Include: unread count per conversation (messages where created_at > participant.last_read_at)
    - Sort by last_message_at DESC (most recent first)
    - Separate message requests at top: conversations with pending MessageRequest where user is recipient
    - Support search query param: filter by other participant's display_name/username (LIKE search)
    - Return: { conversations: [...], messageRequests: [...] }

    **POST /api/chat/conversations** (withAuth):
    - Body: { type: 'direct' | 'group', participant_ids: number[], name?: string }
    - For direct (1:1):
      - participant_ids must have exactly 1 other user
      - Check if direct conversation already exists between these two users — if so, return existing (restore deleted_at if needed)
      - Enforce messaging access rules:
        - Check target user's messaging_access setting
        - 'everyone': allow
        - 'followers': target must follow requester
        - 'mutual': both must follow each other
        - 'nobody': reject (403)
        - Admin/moderators bypass
      - If access not granted: create MessageRequest instead of conversation, return 202 with request info
    - For group:
      - Creator becomes admin, all others become members
      - Max 256 participants
      - Validate all participant_ids exist
      - Creator can only add from their followers (check Follow table)
    - Check block status: cannot create conversation with blocked/blocking users
    - Return created conversation with 201

    **GET /api/chat/conversations/[id]** (withAuth):
    - Return conversation detail with participants
    - Verify user is a participant
    - Include participant list with online status (from presence manager if available)

    **DELETE /api/chat/conversations/[id]** (withAuth):
    - Soft delete: set deleted_at on ConversationParticipant for this user
    - Do NOT delete the conversation or other participant's view
    - Return 200
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Route files export GET, POST, DELETE appropriately
    - Messaging access rules implemented (everyone/followers/mutual/nobody)
  </verify>
  <done>Conversation list API with search, create with access rules, detail, and soft-delete working</done>
</task>

<task type="auto">
  <name>Task 2: Messages API, requests API, and chat media upload</name>
  <files>
    src/app/api/chat/conversations/[id]/messages/route.ts
    src/app/api/chat/conversations/[id]/participants/route.ts
    src/app/api/chat/requests/route.ts
    src/app/api/upload/chat-media/route.ts
  </files>
  <action>
    **GET /api/chat/conversations/[id]/messages** (withAuth):
    - Verify user is participant (deleted_at IS NULL)
    - Cursor-based pagination using existing cursor utility pattern (newest first, paginate backward)
    - 30 messages per page
    - Include: sender info (display_name, username, avatar_url, avatar_color)
    - Include: media attachments (MessageMedia)
    - Include: reply-to message (if reply_to_id set, include original message content + sender)
    - Include: shared post preview (if shared_post_id set)
    - Include: reactions on each message (grouped by type with count + whether current user reacted)
    - Include: message status (for 1:1: sent/delivered/read based on MessageStatus)
    - Filter out messages where sender is blocked by current user
    - Filter out messages where is_unsent = true (show "This message was unsent" placeholder)
    - Update participant's last_read_at to now (batch read receipt)

    **POST /api/chat/conversations/[id]/messages** (withAuth):
    - Verify user is participant
    - Body: { content?: string, type?: 'text'|'media'|'voice'|'shared_post', reply_to_id?: number, shared_post_id?: number, media?: {url, type, duration?, sort_order}[] }
    - Run profanity filter on content (checkAndFlag from existing utility)
    - Create Message in DB
    - Create MessageMedia rows if media provided
    - Create MessageStatus rows for all other participants (status: 'delivered')
    - Update conversation.last_message_id and last_message_at
    - Emit Socket.IO event via getIO(): chatNsp.to(`conv:${id}`).emit("message:new", messagePayload)
    - Rate limit: ~30 messages per minute per conversation (check recent message count)
    - Return created message with 201

    **POST /api/chat/conversations/[id]/messages/[messageId]/unsend** (create as separate route or handle via PUT):
    - Actually, handle unsend as: PUT /api/chat/conversations/[id]/messages with { action: 'unsend', message_id: number }
    - Or simpler: include unsend in the messages route as a DELETE handler
    - **DELETE /api/chat/conversations/[id]/messages** with body { message_id } — sets is_unsent=true on the message (only by sender)
    - Emit Socket.IO: "message:unsent" event to conversation room

    **POST /api/chat/conversations/[id]/participants** (withAuth):
    - Add participant to group conversation (only by admin/creator)
    - Verify participant is in creator's followers
    - Check block status
    - Max 256 participants
    - Emit "participant:added" event

    **DELETE /api/chat/conversations/[id]/participants** (withAuth):
    - Remove participant (admin can remove anyone, member can remove self = leave)
    - Emit "participant:removed" event

    **GET /api/chat/requests** (withAuth):
    - List pending message requests where user is recipient
    - Include requester info and initial message content

    **POST /api/chat/requests** (withAuth):
    - Body: { request_id: number, action: 'accept' | 'decline' }
    - Accept: update MessageRequest status, restore/activate conversation participant
    - Decline: update status to 'declined' (silent, no notification to sender)
    - One attempt only: check if previously declined request exists

    **POST /api/upload/chat-media** (withAuth):
    - Same pattern as existing post-media upload
    - Accept content_type, generate key with prefix 'chat/'
    - Return presigned upload URL + public URL
    - Support image, video, voice MIME types (including audio/webm, audio/mp4)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - All route files export proper HTTP methods
    - Message creation emits Socket.IO events
    - Profanity filter applied to message content
  </verify>
  <done>Complete message CRUD API, participant management, message requests, and chat media upload working</done>
</task>

</tasks>

<verification>
- All API routes compile without TypeScript errors
- withAuth protects all routes
- Messaging access rules enforced on conversation creation
- Messages paginated with cursor utility
- Socket.IO events emitted after message persistence
- Profanity filter applied to chat messages
- Block status checked on all operations
</verification>

<success_criteria>
Full chat REST API operational: users can list conversations, create 1:1/group chats with access rules, send/receive messages with media, manage requests, and upload chat media.
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time/03-04-SUMMARY.md`
</output>
