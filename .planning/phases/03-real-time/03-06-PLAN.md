---
phase: 03-real-time
plan: 06
type: execute
wave: 2
depends_on: ["03-01", "03-03"]
files_modified:
  - src/lib/notifications/create.ts
  - src/lib/notifications/group.ts
  - src/lib/socket/notifications.ts
  - src/lib/socket/index.ts
  - src/app/api/notifications/route.ts
  - src/app/api/notifications/clear/route.ts
autonomous: true

must_haves:
  truths:
    - "createNotification() writes to DB AND pushes via Socket.IO in one call"
    - "Notifications are grouped by group_key with actor counts"
    - "Notification API returns paginated, grouped feed with filter support"
    - "User can mark notifications as read (individually on tap, all at once)"
    - "User can clear/delete notification history"
    - "Self-notifications are suppressed (no notification for own actions)"
    - "Blocked user notifications are suppressed"
  artifacts:
    - path: "src/lib/notifications/create.ts"
      provides: "Centralized notification creation + Socket.IO push"
      exports: ["createNotification"]
    - path: "src/lib/notifications/group.ts"
      provides: "Notification grouping/collapsing logic"
      exports: ["getGroupedNotifications"]
    - path: "src/app/api/notifications/route.ts"
      provides: "Notification feed GET and mark-read PUT"
      exports: ["GET", "PUT"]
  key_links:
    - from: "src/lib/notifications/create.ts"
      to: "src/lib/socket/index.ts"
      via: "getIO() to push notification:new to user room"
      pattern: "getIO.*notification:new"
    - from: "src/app/api/notifications/route.ts"
      to: "src/lib/notifications/group.ts"
      via: "getGroupedNotifications for feed display"
      pattern: "getGroupedNotifications"
---

<objective>
Build the notification system core: centralized createNotification() that writes to DB and pushes via Socket.IO, notification grouping/collapsing logic, Socket.IO /notifications namespace handlers, and API routes for the notification feed.

Purpose: Enable instant in-app notifications for all social interactions (follows, reactions, comments, prayers, messages, mentions).
Output: Notification creation service, grouping logic, namespace handlers, and 2 API route files.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-real-time/03-RESEARCH.md (Pattern 4, Notification Grouping Strategy)
@.planning/phases/03-real-time/03-CONTEXT.md (notification activity feed decisions)
@.planning/phases/03-real-time/03-01-SUMMARY.md
@.planning/phases/03-real-time/03-03-SUMMARY.md
@src/lib/notifications/types.ts
@src/lib/utils/api.ts (withAuth)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification service and Socket.IO handlers</name>
  <files>
    src/lib/notifications/create.ts
    src/lib/notifications/group.ts
    src/lib/socket/notifications.ts
    src/lib/socket/index.ts
  </files>
  <action>
    1. Create `src/lib/notifications/create.ts`:
       - Export async function createNotification(params: CreateNotificationParams):
         - params: { recipient_id, actor_id, type, entity_type, entity_id, preview_text?, group_key? }
         - Skip if recipient_id === actor_id (no self-notifications)
         - Check block status: import getBlockedUserIds, skip if actor is blocked by recipient
         - Auto-generate group_key if not provided:
           - reaction -> `reaction:${entity_type}:${entity_id}`
           - comment -> `comment:${entity_type}:${entity_id}`
           - prayer -> `prayer:prayer_request:${entity_id}`
           - follow/follow_request/message/mention -> null (not grouped)
         - Create Notification in DB
         - Fetch actor info (User findByPk: id, display_name, username, avatar_url, avatar_color)
         - Push via Socket.IO: try { getIO().of("/notifications").to(`user:${recipient_id}`).emit("notification:new", payload) } catch { /* Socket.IO may not be initialized in tests */ }
         - Return created notification

    2. Create `src/lib/notifications/group.ts`:
       - Export async function getGroupedNotifications(userId, options):
         - options: { cursor?: string, limit?: number, filter?: 'all'|'follows'|'reactions'|'comments'|'prayer', unreadOnly?: boolean }
         - Query strategy: Get latest notification per group_key (or per id if no group_key) for recipient
         - For each grouped notification, get actor_count (COUNT DISTINCT actor_id with same group_key)
         - For grouped notifications, also get the 2-3 most recent actor names for display ("John, Sarah, and 3 others")
         - Apply filter if provided:
           - 'follows' -> type IN ('follow', 'follow_request')
           - 'reactions' -> type = 'reaction'
           - 'comments' -> type = 'comment'
           - 'prayer' -> type = 'prayer'
         - Cursor-based pagination (by created_at DESC, id DESC)
         - Return: { notifications: NotificationPayload[], nextCursor: string | null, unreadCount: number }

    3. Create `src/lib/socket/notifications.ts`:
       - Export function registerNotificationHandlers(nsp, socket):
         - socket already joins `user:${userId}` room in index.ts
         - Handle "notification:mark-read" event: { notificationId: number } -> update is_read = true in DB
         - Handle "notification:mark-all-read" event: update all unread for user
         - Handle "notifications:subscribe" event (optional): acknowledge connection ready

    4. Update `src/lib/socket/index.ts`:
       - Import registerNotificationHandlers from "./notifications"
       - In /notifications namespace connection handler, call registerNotificationHandlers(notifNsp, socket)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - createNotification exported and handles self/block suppression
    - getGroupedNotifications returns grouped results with actor counts
    - Notification handlers registered in Socket.IO
  </verify>
  <done>Notification creation service writes DB + pushes Socket.IO, grouping logic collapses similar notifications, namespace handlers registered</done>
</task>

<task type="auto">
  <name>Task 2: Create notification API routes</name>
  <files>
    src/app/api/notifications/route.ts
    src/app/api/notifications/clear/route.ts
  </files>
  <action>
    **GET /api/notifications** (withAuth):
    - Query params: cursor?, limit? (default 20), filter? ('all'|'follows'|'reactions'|'comments'|'prayer')
    - Call getGroupedNotifications(userId, options)
    - Also return total unread count (for badge)
    - Return: { notifications, nextCursor, unreadCount }

    **PUT /api/notifications** (withAuth):
    - Body: { action: 'mark-read', notification_id?: number }
    - If notification_id provided: mark that single notification as read
    - If no notification_id (action: 'mark-all-read'): mark all unread notifications for user as read
    - Return: { success: true, unreadCount: number }

    **DELETE /api/notifications/clear** (withAuth):
    - Delete all notifications for the user (hard delete â€” not needed after 30 days anyway)
    - Return: { success: true }

    **Additional consideration:**
    - Endpoint for getting unread count only (lightweight): GET /api/notifications?count_only=true
    - Returns just { unreadCount: number } for badge updates
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - GET returns grouped notifications with cursor pagination
    - PUT marks read (single or all)
    - DELETE clears notification history
  </verify>
  <done>Notification API routes provide feed with grouping, mark-read, and clear functionality</done>
</task>

</tasks>

<verification>
- createNotification() correctly suppresses self-notifications and blocked users
- Grouped notifications show "X and N others" pattern
- API routes return paginated, filterable notification feed
- Socket.IO pushes real-time notifications to user rooms
- Mark-read works both individually and in bulk
</verification>

<success_criteria>
Complete notification system core: createNotification() as single entry point for all notification creation, grouped feed with filtering, mark-read/clear operations, real-time Socket.IO delivery.
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time/03-06-SUMMARY.md`
</output>
