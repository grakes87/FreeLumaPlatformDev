---
phase: 03-real-time
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - server.js
  - src/lib/socket/index.ts
  - src/lib/socket/auth.ts
  - src/lib/socket/presence.ts
  - src/context/SocketContext.tsx
  - src/hooks/useSocket.ts
autonomous: true

must_haves:
  truths:
    - "Socket.IO server initializes and attaches to the existing HTTP server on startup"
    - "Socket.IO auth middleware extracts auth_token cookie and verifies JWT"
    - "Two namespaces (/chat and /notifications) are registered with auth middleware"
    - "Presence manager tracks online users by userId -> Set<socketId>"
    - "React SocketProvider connects to both namespaces when user is authenticated"
  artifacts:
    - path: "src/lib/socket/index.ts"
      provides: "Socket.IO server init, getIO() singleton, initSocketServer()"
      exports: ["getIO", "initSocketServer"]
    - path: "src/lib/socket/auth.ts"
      provides: "Socket.IO auth middleware for JWT verification"
      exports: ["authMiddleware"]
    - path: "src/lib/socket/presence.ts"
      provides: "In-memory presence tracking"
      exports: ["presenceManager"]
    - path: "src/context/SocketContext.tsx"
      provides: "React context for socket connections"
      exports: ["SocketProvider", "useSocket"]
  key_links:
    - from: "server.js"
      to: "src/lib/socket/index.ts"
      via: "dynamic import initSocketServer()"
      pattern: "initSocketServer"
    - from: "src/lib/socket/auth.ts"
      to: "src/lib/auth/jwt.ts"
      via: "verifyJWT from existing auth"
      pattern: "verifyJWT"
    - from: "src/context/SocketContext.tsx"
      to: "socket.io-client"
      via: "io() connection to /chat and /notifications"
      pattern: "io\\(\"/chat\""
---

<objective>
Install Socket.IO dependencies, create the server-side Socket.IO initialization with namespace separation (/chat and /notifications), cookie-based JWT auth middleware, in-memory presence manager, and client-side React context/hook for socket connections.

Purpose: Establish the real-time transport layer that all chat and notification features depend on.
Output: Working Socket.IO server attached to existing HTTP server, client-side socket context provider.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time/03-RESEARCH.md
@server.js
@src/lib/auth/jwt.ts
@src/lib/db/index.ts (for globalThis caching pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create Socket.IO server infrastructure</name>
  <files>
    package.json
    server.js
    src/lib/socket/index.ts
    src/lib/socket/auth.ts
    src/lib/socket/presence.ts
  </files>
  <action>
    1. Install dependencies:
       ```bash
       npm install socket.io@^4.8.3 socket.io-client@^4.8.3 cookie@^1.0.2 node-cron@^3.0.3 uuid@^11.0.0
       npm install -D @types/cookie @types/node-cron @types/uuid
       ```

    2. Create `src/lib/socket/presence.ts`:
       - PresenceManager class with Map<number, Set<string>> (userId -> socketIds)
       - Methods: addUser(userId, socketId), removeSocket(userId, socketId), isOnline(userId), getOnlineUserIds(), getOnlineStatusBulk(userIds[])
       - Export singleton `presenceManager`

    3. Create `src/lib/socket/auth.ts`:
       - Import `parse as parseCookie` from "cookie"
       - Import `verifyJWT` from "@/lib/auth/jwt"
       - Export async function `authMiddleware(socket, next)`:
         - Extract cookie header from `socket.handshake.headers.cookie`
         - Parse with parseCookie, extract `auth_token`
         - Verify with `verifyJWT(token)`
         - Attach `socket.data.userId` and `socket.data.email` from payload
         - Call `next()` on success, `next(new Error(...))` on failure

    4. Create `src/lib/socket/index.ts`:
       - Import Server from "socket.io", authMiddleware, presenceManager
       - Use globalThis caching pattern (like src/lib/db/index.ts) for dev HMR: store io on globalThis.__io
       - `initSocketServer(httpServer)`:
         - Create SocketServer with connectionStateRecovery (maxDisconnectionDuration: 2min)
         - Set up /chat namespace with authMiddleware, placeholder connection handler (registerChatHandlers will be added in 03-05)
         - Set up /notifications namespace with authMiddleware, join user room `user:{userId}` on connect
         - Memory leak prevention: io.engine.on("connection", rawSocket => rawSocket.request = null)
         - Store on globalThis.__io in dev
       - `getIO()`: Return io instance (from globalThis in dev, module-level in prod), throw if not initialized

    5. Update `server.js`:
       - Add dynamic import for initSocketServer: `const { initSocketServer } = await import("./src/lib/socket/index.js");`
       - Call `initSocketServer(httpServer)` BEFORE httpServer.listen()
       - Note: server.js is ESM (package type "module"), so use dynamic import for the TS-compiled path
       - The import path should be `"./src/lib/socket/index.js"` — Next.js custom server with ESM handles this
       - Actually, since this is a .js file importing from src/lib, use the pattern that works with the existing setup. Check if server.js can import TS files or needs a different approach. If it cannot import TS directly, create a thin wrapper or use the approach from the research: import from the compiled output. Given the existing server.js is simple ESM, the safest approach is to keep socket init in server.js itself or use a .js file. **Best approach**: Create the socket init logic with proper types in .ts files for API route usage (getIO), but have server.js do the initialization inline using the socket.io import directly, then store the io instance on globalThis for getIO() to access from API routes.
       - Revised server.js approach:
         ```js
         import { createServer } from "node:http";
         import { Server as SocketServer } from "socket.io";
         import next from "next";

         // ... existing setup ...

         app.prepare().then(async () => {
           const httpServer = createServer(handler);

           // Initialize Socket.IO
           const io = new SocketServer(httpServer, {
             connectionStateRecovery: { maxDisconnectionDuration: 2 * 60 * 1000 },
           });
           globalThis.__io = io;

           // Auth middleware will be applied when namespaces register handlers
           // (handlers registered from within Next.js API/lib code on first import)

           io.engine.on("connection", (rawSocket) => { rawSocket.request = null; });

           httpServer.listen(port, hostname, () => {
             console.log(`> Ready on http://${hostname}:${port}`);
           });
         });
         ```
       - Then in `src/lib/socket/index.ts`, `getIO()` reads from `globalThis.__io`
       - The namespace setup (/chat, /notifications) with auth middleware happens lazily on first getIO() call or via an `ensureNamespaces()` function that index.ts exports and that gets called when the first socket-dependent code runs

       **FINAL APPROACH** (simplest, most reliable):
       - server.js creates the raw SocketServer and stores on globalThis.__io
       - src/lib/socket/index.ts provides getIO() that reads globalThis.__io, and a setupNamespaces() that applies auth middleware and registers namespace handlers (called once, guarded by a flag)
       - setupNamespaces() is called from getIO() if not yet done (lazy init pattern)
  </action>
  <verify>
    - `npm ls socket.io` shows 4.8.x installed
    - `npm ls socket.io-client` shows 4.8.x installed
    - `npm ls cookie` shows installed
    - `npx tsc --noEmit` passes for new files
    - server.js has Socket.IO initialization code
  </verify>
  <done>Socket.IO server initializes on startup, auth middleware verifies JWT from cookie, presence manager tracks online users, getIO() accessible from API routes</done>
</task>

<task type="auto">
  <name>Task 2: Create client-side Socket context and hook</name>
  <files>
    src/context/SocketContext.tsx
    src/hooks/useSocket.ts
  </files>
  <action>
    1. Create `src/context/SocketContext.tsx`:
       - "use client" directive
       - Import io from "socket.io-client", createContext, useContext, useEffect, useRef, useState
       - Import useAuth from existing hook (check if useAuth exists at @/hooks/useAuth or if auth state comes from AuthContext)
       - SocketContextValue interface: { chatSocket: Socket | null, notifSocket: Socket | null, isConnected: boolean }
       - SocketProvider component:
         - Get auth state (isAuthenticated) from useAuth or check for auth cookie
         - useEffect dependent on isAuthenticated:
           - If not authenticated, return (don't connect)
           - Create chatSocket = io("/chat", { autoConnect: true, withCredentials: true })
           - Create notifSocket = io("/notifications", { autoConnect: true, withCredentials: true })
           - Store in refs
           - Listen for "connect"/"disconnect" on chatSocket to update isConnected state
           - Cleanup: disconnect both sockets on unmount or auth change
         - Provide context value

    2. Create `src/hooks/useSocket.ts`:
       - Simple re-export of useContext(SocketContext)
       - Or if SocketContext exports useSocket directly, just re-export from there

    3. **Important**: Do NOT wrap the app layout with SocketProvider yet — that will be done in the integration plan (03-13). Just create the provider and hook. The provider needs the auth state, so verify how useAuth works by checking `src/hooks/useAuth.ts` or `src/context/AuthContext.tsx`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - SocketContext.tsx exports SocketProvider and useSocket
    - useSocket.ts exists and exports the hook
  </verify>
  <done>SocketProvider and useSocket hook ready for wrapping authenticated layout, connects to /chat and /notifications namespaces</done>
</task>

</tasks>

<verification>
- All new files compile without TypeScript errors
- socket.io, socket.io-client, cookie, node-cron, uuid packages installed
- server.js creates Socket.IO server and stores on globalThis
- getIO() function accessible from src/lib/socket/index.ts
- Auth middleware correctly parses cookie and verifies JWT
- PresenceManager tracks user connections
- SocketProvider connects to both namespaces when authenticated
</verification>

<success_criteria>
Socket.IO infrastructure is operational: server starts with Socket.IO attached, auth middleware protects namespaces, presence tracking works, and client-side context is ready for integration.
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time/03-01-SUMMARY.md`
</output>
