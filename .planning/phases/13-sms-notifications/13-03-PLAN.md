---
phase: 13-sms-notifications
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - src/lib/sms/templates.ts
  - src/lib/sms/queue.ts
  - src/lib/email/queue.ts
  - src/app/api/sms/verify/route.ts
  - src/app/api/sms/webhook/route.ts
autonomous: true

must_haves:
  truths:
    - "SMS templates exist for all 6 notification categories, each under 160 characters"
    - "dispatchSMSNotification checks global toggle + per-category toggle + quiet hours + rate limit"
    - "isInQuietHours is exported from email/queue.ts for reuse"
    - "POST /api/sms/verify sends OTP to phone number"
    - "PUT /api/sms/verify validates OTP code and sets phone_verified=true on user"
    - "POST /api/sms/webhook handles Twilio STOP/START inbound messages"
    - "Webhook validates Twilio request signature"
  artifacts:
    - path: "src/lib/sms/templates.ts"
      provides: "SMS message templates per category"
      exports: ["smsTemplates"]
    - path: "src/lib/sms/queue.ts"
      provides: "SMS dispatch logic with per-category checks"
      exports: ["dispatchSMSNotification"]
    - path: "src/app/api/sms/verify/route.ts"
      provides: "OTP send and verify API"
      exports: ["POST", "PUT"]
    - path: "src/app/api/sms/webhook/route.ts"
      provides: "Twilio inbound webhook handler"
      exports: ["POST"]
  key_links:
    - from: "src/lib/sms/queue.ts"
      to: "src/lib/sms/index.ts"
      via: "import sendSMS"
      pattern: "import.*sendSMS.*from.*sms/index"
    - from: "src/lib/sms/queue.ts"
      to: "src/lib/email/queue.ts"
      via: "import isInQuietHours"
      pattern: "import.*isInQuietHours"
    - from: "src/app/api/sms/verify/route.ts"
      to: "src/lib/sms/verify.ts"
      via: "import sendOTP, checkOTP"
      pattern: "import.*from.*sms/verify"
---

<objective>
Create SMS templates, dispatch queue, OTP API routes, and Twilio webhook handler.

Purpose: Wiring layer — connects the SMS library (Plan 02) to the database (Plan 01) via dispatch logic and API routes.
Output: SMS templates, dispatch queue with full guard chain, OTP verification API, Twilio inbound webhook.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/13-sms-notifications/13-RESEARCH.md
@src/lib/email/queue.ts
@src/lib/sms/index.ts (from Plan 02)
@src/lib/sms/verify.ts (from Plan 02)
@src/lib/utils/phone.ts (from Plan 02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SMS templates, dispatch queue, and export isInQuietHours</name>
  <files>
    src/lib/sms/templates.ts
    src/lib/sms/queue.ts
    src/lib/email/queue.ts
  </files>
  <action>
    **1. Export isInQuietHours from email/queue.ts:**
    The `isInQuietHours` function in `src/lib/email/queue.ts` is currently a module-private function. Add `export` keyword to it so SMS queue can import it. No other changes to email/queue.ts.

    **2. Create `src/lib/sms/templates.ts`:**
    Define `smsTemplates` — a Record mapping notification type strings to template functions that return SMS body strings.

    Each template takes `(preview: string | null, entityId: number)` and returns a string.

    Templates (ALL must be under 160 characters):
    - `follow`: `"${preview || 'Someone'} followed you on Free Luma. ${APP_SHORT_URL}"`
    - `prayer`: `"Someone prayed for your request on Free Luma. You're not alone. ${APP_SHORT_URL}"`
    - `message`: `"New message on Free Luma. ${APP_SHORT_URL}/chat"`
    - `workshop_reminder`: `"Reminder: Workshop starts in 1hr! ${APP_SHORT_URL}/workshops/${entityId}"`
    - `workshop_started`: `"Workshop is live now! Join: ${APP_SHORT_URL}/workshops/${entityId}"`
    - `daily_reminder`: `"Your daily inspiration is ready on Free Luma. Start your day with faith. ${APP_SHORT_URL}"`

    Use `const APP_SHORT_URL = 'freeluma.com';`

    **3. Create `src/lib/sms/queue.ts`:**

    Define `SMS_CATEGORY_MAP` mapping notification types to user_settings column names:
    ```
    follow -> sms_follow_notifications
    follow_request -> sms_follow_notifications
    prayer -> sms_prayer_notifications
    message -> sms_dm_notifications
    workshop_reminder -> sms_workshop_notifications
    workshop_started -> sms_workshop_notifications
    daily_reminder -> sms_daily_reminder
    ```

    Define `MAX_SMS_PER_HOUR = 3` (lower than email's 5 due to cost).

    Create `isRateLimitedSMS(userId: number): Promise<boolean>`:
    - Count SmsLog entries with status 'sent'/'delivered' and sent_at within last hour.
    - Return true if >= MAX_SMS_PER_HOUR.

    Create `dispatchSMSNotification(recipientId: number, type: string, entityType: string, entityId: number, previewText: string | null): Promise<void>`:
    1. Look up `settingColumn` from SMS_CATEGORY_MAP. If not found, return (not SMS-eligible type).
    2. Load user (id, phone, phone_verified) from User model.
    3. If no phone or phone_verified is false, return.
    4. Load user settings. Check sms_notifications_enabled (global toggle). If false, return.
    5. Check per-category toggle via `settings[settingColumn]`. If false, return.
    6. Check quiet hours via imported `isInQuietHours()` from email/queue.ts.
    7. Check rate limit via isRateLimitedSMS().
    8. Get SMS body from smsTemplates[type]. If no template, return.
    9. Create SmsLog entry with status 'queued'.
    10. Call sendSMS(). Update SmsLog with status + twilio_sid + sent_at.
    11. Wrap entire function in try/catch — never throw (fire-and-forget).
  </action>
  <verify>
    Files exist. TypeScript compiles.
    All 6 SMS templates are under 160 characters (count manually or with template literal evaluation).
    isInQuietHours is now exported from email/queue.ts.
    dispatchSMSNotification has the full guard chain: phone exists, phone_verified, global toggle, per-category toggle, quiet hours, rate limit.
  </verify>
  <done>SMS templates under 160 chars, dispatch queue with full guard chain, isInQuietHours exported for reuse.</done>
</task>

<task type="auto">
  <name>Task 2: Create OTP verification API and Twilio inbound webhook</name>
  <files>
    src/app/api/sms/verify/route.ts
    src/app/api/sms/webhook/route.ts
  </files>
  <action>
    **1. Create `src/app/api/sms/verify/route.ts`:**

    POST handler (send OTP) — protected with withAuth:
    - Parse body: `{ phone: string }`
    - Validate with Zod: phone is a non-empty string
    - Normalize phone via `normalizePhone()` from utils/phone.ts. Return 400 if null.
    - Call `sendOTP(normalizedPhone)` from sms/verify.ts.
    - If success: update User record with `phone = normalizedPhone, phone_verified = false`. Return 200 `{ success: true }`.
    - If failure: return 400 with error message.

    PUT handler (verify OTP) — protected with withAuth:
    - Parse body: `{ phone: string, code: string }`
    - Validate: phone non-empty string, code 6-digit string (regex /^\d{6}$/)
    - Normalize phone. Return 400 if null.
    - Verify the phone matches the user's stored phone. Return 400 "Phone number mismatch" if different.
    - Call `checkOTP(normalizedPhone, code)`.
    - If success: update User with `phone_verified = true`. Ensure sms_notifications_enabled is set to true on UserSetting (auto-enable on verification). Return 200 `{ success: true, phone_verified: true }`.
    - If failure: return 400 with error message.

    **2. Create `src/app/api/sms/webhook/route.ts`:**

    POST handler — NO auth middleware (Twilio calls this):
    - Parse form-encoded body from request text via `new URLSearchParams(body)`.
    - Validate Twilio signature using `twilio.validateRequest()`:
      - Get X-Twilio-Signature header.
      - Reconstruct canonical URL: use `X-Forwarded-Proto` + `X-Forwarded-Host` headers if present (for production behind reverse proxy), else use `req.url`.
      - Call `twilio.validateRequest(TWILIO_AUTH_TOKEN, signature, canonicalUrl, params)`.
      - If invalid: return 403 JSON error.
      - If TWILIO_AUTH_TOKEN is not set (dev mode): skip validation with console warning.
    - Extract `From` (E.164 phone) and `OptOutType` from params.
    - If OptOutType is 'STOP':
      - Find user by phone in User model.
      - If found: set `sms_notifications_enabled = false` on UserSetting.
      - Log: `[SMS Webhook] STOP from {From}, user {userId}`
    - If OptOutType is 'START':
      - Find user by phone.
      - If found: set `sms_notifications_enabled = true` on UserSetting.
      - Log: `[SMS Webhook] START from {From}, user {userId}`
    - Return TwiML empty response: `<?xml version="1.0" encoding="UTF-8"?><Response></Response>` with Content-Type text/xml.
  </action>
  <verify>
    Files exist with POST and PUT exports.
    TypeScript compiles.
    OTP route is protected with withAuth.
    Webhook route has NO auth middleware but validates Twilio signature.
    Webhook returns XML response.
  </verify>
  <done>OTP API accepts phone number, sends OTP, verifies code, and sets phone_verified. Webhook syncs STOP/START to sms_notifications_enabled.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. All 5 files created/modified
3. SMS templates all under 160 chars
4. dispatchSMSNotification has complete guard chain
5. OTP API validates phone, sends/checks OTP, updates user
6. Webhook validates Twilio signature and syncs opt-out status
</verification>

<success_criteria>
- 6 SMS templates defined, all under 160 characters with deep links
- dispatchSMSNotification checks: phone exists, phone_verified, global toggle, per-category toggle, quiet hours, rate limit
- isInQuietHours exported from email/queue.ts
- POST /api/sms/verify sends OTP and saves phone to user
- PUT /api/sms/verify validates OTP and sets phone_verified=true
- POST /api/sms/webhook handles STOP/START and syncs to user_settings
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/13-sms-notifications/13-03-SUMMARY.md`
</output>
