---
phase: 05-workshops
plan: 06
type: execute
wave: 3
depends_on: [05-01, 05-02, 05-05]
files_modified:
  - src/app/api/workshops/[id]/start/route.ts
  - src/app/api/workshops/[id]/end/route.ts
  - src/app/api/workshops/[id]/token/route.ts
  - src/app/api/workshops/recording-callback/route.ts
autonomous: true

must_haves:
  truths:
    - "Host can start a workshop, transitioning it from scheduled/lobby to live"
    - "Starting a workshop triggers Agora Cloud Recording automatically"
    - "Host can end a workshop, stopping the recording"
    - "Authenticated users joining a workshop receive a time-limited Agora RTC token"
    - "Recording callback processes Agora webhook to publish recording to video library"
  artifacts:
    - path: "src/app/api/workshops/[id]/start/route.ts"
      provides: "Workshop start endpoint with recording trigger"
      exports: ["POST"]
    - path: "src/app/api/workshops/[id]/end/route.ts"
      provides: "Workshop end endpoint with recording stop"
      exports: ["POST"]
    - path: "src/app/api/workshops/[id]/token/route.ts"
      provides: "Agora RTC token generation endpoint"
      exports: ["GET"]
    - path: "src/app/api/workshops/recording-callback/route.ts"
      provides: "Agora Cloud Recording webhook handler"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/workshops/[id]/start/route.ts"
      to: "src/lib/workshop/cloud-recording.ts"
      via: "startCloudRecording import"
      pattern: "startCloudRecording"
    - from: "src/app/api/workshops/[id]/token/route.ts"
      to: "src/lib/workshop/agora-token.ts"
      via: "generateAgoraToken import"
      pattern: "generateAgoraToken"
---

<objective>
Create the workshop lifecycle API endpoints: start, end, Agora token generation, and recording webhook callback. These endpoints manage the critical state transitions and Agora integration.

Purpose: These endpoints bridge the workshop state machine with Agora's media infrastructure — starting recording when workshops go live, stopping on end, and processing recordings into the video library.
Output: 4 API route files for lifecycle management.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-workshops/05-CONTEXT.md
@.planning/phases/05-workshops/05-RESEARCH.md
@src/lib/auth/middleware.ts
@src/lib/workshop/agora-token.ts
@src/lib/workshop/cloud-recording.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Workshop start and end lifecycle endpoints</name>
  <files>src/app/api/workshops/[id]/start/route.ts, src/app/api/workshops/[id]/end/route.ts</files>
  <action>
    **Start route (start/route.ts) — POST (withAuth):**

    State transition: scheduled -> live (or lobby -> live)

    Steps:
    1. Validate caller is the host (host_id === user.id) — co-hosts CANNOT start
    2. Validate workshop status is 'scheduled' or 'lobby'
    3. Use sequelize.transaction for atomic state change:
       a. Re-read workshop status inside transaction (race condition guard with no-show cron)
       b. If status is not 'scheduled' or 'lobby', return 409 "Workshop already started or cancelled"
       c. Update workshop: status='live', actual_started_at=NOW()
    4. After transaction commits, trigger Cloud Recording (fire-and-forget with error logging):
       a. Generate recording token: `generateAgoraToken(agora_channel, getRecordingUid(workshop.id), 'host')`
       b. Acquire resource: `acquireRecordingResource(agora_channel, getRecordingUid(workshop.id))`
       c. Start recording: `startCloudRecording(agora_channel, getRecordingUid(workshop.id), token, resourceId)`
       d. Update workshop with recording_sid and recording_resource_id
       e. If recording fails, log error but don't fail the start (workshop can proceed without recording)
    5. Broadcast workshop state change via Socket.IO:
       - Get io from getIO(), emit to `/workshop` namespace room `workshop:${workshopId}`
       - Emit `workshop:state-changed` with { status: 'live', startedAt }
    6. Return { workshop: updated, recording: { started: boolean } }

    **End route (end/route.ts) — POST (withAuth):**

    State transition: live -> ended

    Steps:
    1. Validate caller is host
    2. Validate workshop status is 'live'
    3. Update workshop: status='ended', actual_ended_at=NOW()
    4. Stop Cloud Recording (fire-and-forget):
       a. If recording_resource_id and recording_sid exist:
       b. `stopCloudRecording(agora_channel, getRecordingUid(workshop.id), recording_resource_id, recording_sid)`
       c. Store returned fileList on workshop (optional — webhook handles this too)
    5. Broadcast workshop state change via Socket.IO:
       - Emit `workshop:state-changed` with { status: 'ended', endedAt }
    6. Update all WorkshopAttendee with status='joined' to status='left', left_at=NOW()
    7. Return { workshop: updated }
  </action>
  <verify>TypeScript compiles. Start uses transaction for race condition safety. End stops recording.</verify>
  <done>Workshop start triggers recording and transitions to live. End stops recording and transitions to ended.</done>
</task>

<task type="auto">
  <name>Task 2: Agora token endpoint and recording callback</name>
  <files>src/app/api/workshops/[id]/token/route.ts, src/app/api/workshops/recording-callback/route.ts</files>
  <action>
    **Token route (token/route.ts) — GET (withAuth):**

    Generate Agora RTC token for user joining a workshop.

    Steps:
    1. Validate workshop exists and is in 'live' state (only issue tokens for live workshops)
    2. Check authorization:
       - Host: always allowed, role = 'host'
       - Co-host (WorkshopAttendee.is_co_host=true): role = 'host' (publishes video)
       - Approved speaker (WorkshopAttendee.can_speak=true): role = 'host' (publishes audio only — client decides what to publish)
       - RSVP'd attendee: role = 'audience'
       - If private: must be invited or RSVP'd
       - Otherwise: 403
    3. Generate token: `generateAgoraToken(workshop.agora_channel, user.id, role)`
    4. Return: { token, channelName: workshop.agora_channel, uid: user.id, role, appId: process.env.NEXT_PUBLIC_AGORA_APP_ID }

    **Recording callback route (recording-callback/route.ts) — POST (no auth — webhook):**

    Handle Agora Cloud Recording webhook notifications.

    Steps:
    1. Parse request body — Agora sends: { noticeId, productId, eventType, payload }
    2. Event types to handle:
       - eventType 31 (recording uploaded): Extract fileList from payload
       - eventType 40 (recording service error): Log error
    3. For eventType 31:
       a. Extract channel name from payload.cname (format: workshop-{id})
       b. Find workshop by agora_channel
       c. Extract MP4 file URL from fileList (filter by fileName ending in .mp4)
       d. Construct full recording URL: `https://${B2_CDN_DOMAIN}/${fileName}` or presigned URL
       e. Update workshop: recording_url = URL
       f. Create a Video entry in the video library:
          - title: workshop.title + " (Recording)"
          - description: workshop.description
          - video_url: recording URL
          - uploaded_by: workshop.host_id
          - duration_seconds: calculated from actual_started_at to actual_ended_at
          - published: true
          - published_at: NOW()
          - category_id: map WorkshopCategory to VideoCategory if possible, else null
       g. Notify all RSVP'd attendees that recording is available (fire-and-forget createNotification type='workshop_recording')
    4. Return 200 OK (Agora expects 200 response)

    Security: Consider validating Agora webhook signature if provided, or validate by checking that the channelName matches an existing workshop. Since this endpoint is publicly accessible, add basic validation.
  </action>
  <verify>TypeScript compiles. Token endpoint returns proper role for host vs attendee. Recording callback creates Video entry.</verify>
  <done>Token generation provides role-based access. Recording callback publishes to video library and notifies attendees.</done>
</task>

</tasks>

<verification>
1. POST /api/workshops/[id]/start transitions to live and triggers recording
2. POST /api/workshops/[id]/end transitions to ended and stops recording
3. GET /api/workshops/[id]/token returns role-based Agora token
4. POST /api/workshops/recording-callback processes recording and creates Video entry
5. Start uses DB transaction to prevent race condition with no-show cron
6. Recording failures don't block workshop start
</verification>

<success_criteria>
- Workshop lifecycle state machine enforced (scheduled/lobby -> live -> ended)
- Cloud Recording starts/stops automatically with workshop
- Agora tokens are role-based (host publishes video+audio, audience subscribes only)
- Recording webhook publishes to video library and sends notifications
- Race condition between start and no-show cron handled via transaction
</success_criteria>

<output>
After completion, create `.planning/phases/05-workshops/05-06-SUMMARY.md`
</output>
