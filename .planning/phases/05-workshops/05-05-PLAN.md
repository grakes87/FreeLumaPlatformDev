---
phase: 05-workshops
plan: 05
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - src/lib/socket/workshop.ts
  - src/lib/socket/index.ts
  - src/hooks/useWorkshopSocket.ts
  - src/hooks/useWorkshopChat.ts
autonomous: true

must_haves:
  truths:
    - "Socket.IO /workshop namespace exists with auth middleware"
    - "Users can join and leave workshop rooms via Socket.IO"
    - "Raise hand requests are broadcast to the workshop room"
    - "Host can approve/revoke speaker and promote co-host via socket events"
    - "In-room chat messages are persisted and broadcast in real-time"
    - "Workshop state changes are broadcast to all room participants"
  artifacts:
    - path: "src/lib/socket/workshop.ts"
      provides: "Workshop Socket.IO namespace handlers"
      exports: ["registerWorkshopHandlers"]
    - path: "src/lib/socket/index.ts"
      provides: "Updated setup with /workshop namespace"
      contains: "/workshop"
    - path: "src/hooks/useWorkshopSocket.ts"
      provides: "Client-side workshop Socket.IO hook"
      exports: ["useWorkshopSocket"]
    - path: "src/hooks/useWorkshopChat.ts"
      provides: "Client-side workshop chat hook"
      exports: ["useWorkshopChat"]
  key_links:
    - from: "src/lib/socket/index.ts"
      to: "src/lib/socket/workshop.ts"
      via: "registerWorkshopHandlers import"
      pattern: "registerWorkshopHandlers"
    - from: "src/hooks/useWorkshopSocket.ts"
      to: "socket.io-client"
      via: "io('/workshop') connection"
      pattern: "io.*workshop"
---

<objective>
Create the Socket.IO /workshop namespace for all workshop real-time signaling: room membership, raise hand, speaker management, co-host promotion, in-room chat, and workshop state broadcasting. Also create client-side hooks for workshop socket connection and chat.

Purpose: All live workshop features (lobby, raise hand, chat, host controls) rely on Socket.IO signaling. Agora handles ONLY media — Socket.IO handles everything else.
Output: Server-side namespace handlers, updated socket index, 2 client hooks.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-workshops/05-CONTEXT.md
@.planning/phases/05-workshops/05-RESEARCH.md
@src/lib/socket/index.ts
@src/lib/socket/chat.ts
@src/hooks/useSocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Socket.IO /workshop namespace server handlers</name>
  <files>src/lib/socket/workshop.ts, src/lib/socket/index.ts</files>
  <action>
    **workshop.ts:**
    Create `registerWorkshopHandlers(nsp: Namespace, socket: Socket): void` following the exact pattern from src/lib/socket/chat.ts.

    Events to handle:

    **workshop:join** ({ workshopId: number })
    - Lazy-import Workshop, WorkshopAttendee from models
    - Validate workshop exists and is in valid state (scheduled, lobby, live)
    - Validate user is host, co-host, RSVP'd, or invited (for private)
    - Join socket room `workshop:${workshopId}`
    - If workshop is 'live' or 'lobby', update WorkshopAttendee status to 'joined' and set joined_at
    - Broadcast `workshop:user-joined` to room: { userId, displayName, avatarUrl, isHost, isCoHost }
    - Send `workshop:state` to joining user: { status, attendees[], hostId, coHostIds[], startedAt }

    **workshop:leave** ({ workshopId: number })
    - Leave socket room
    - Update WorkshopAttendee: status='left', left_at=now
    - Broadcast `workshop:user-left` to room: { userId }

    **workshop:raise-hand** ({ workshopId: number })
    - Broadcast `workshop:hand-raised` to room: { userId }

    **workshop:lower-hand** ({ workshopId: number })
    - Broadcast `workshop:hand-lowered` to room: { userId }

    **workshop:approve-speaker** ({ workshopId: number, targetUserId: number })
    - Validate caller is host or co-host (check DB)
    - Update WorkshopAttendee set can_speak=true for targetUserId
    - Broadcast `workshop:speaker-approved` to room: { userId: targetUserId }

    **workshop:revoke-speaker** ({ workshopId: number, targetUserId: number })
    - Validate caller is host or co-host
    - Update WorkshopAttendee set can_speak=false for targetUserId
    - Broadcast `workshop:speaker-revoked` to room: { userId: targetUserId }

    **workshop:promote-cohost** ({ workshopId: number, targetUserId: number })
    - Validate caller is host (not co-host — only host can promote)
    - Update WorkshopAttendee set is_co_host=true, can_speak=true for targetUserId
    - Broadcast `workshop:cohost-promoted` to room: { userId: targetUserId }

    **workshop:demote-cohost** ({ workshopId: number, targetUserId: number })
    - Validate caller is host
    - Update WorkshopAttendee set is_co_host=false for targetUserId
    - Broadcast `workshop:cohost-demoted` to room: { userId: targetUserId }

    **workshop:mute-user** ({ workshopId: number, targetUserId: number })
    - Validate caller is host or co-host
    - Broadcast `workshop:user-muted` to room: { userId: targetUserId }
    - (Client handles actual audio muting via Agora SDK)

    **workshop:remove-user** ({ workshopId: number, targetUserId: number })
    - Validate caller is host or co-host
    - Update WorkshopAttendee: status='left', left_at=now
    - Broadcast `workshop:user-removed` to room: { userId: targetUserId }
    - (Client handles Agora channel leave for removed user)

    **workshop:chat** ({ workshopId: number, message: string })
    - Validate message is non-empty (max 1000 chars)
    - Lazy-import Workshop to get actual_started_at
    - Calculate offset_ms = Date.now() - actual_started_at.getTime()
    - If workshop status is not 'live', offset_ms = 0 (chat during lobby)
    - Create WorkshopChat row
    - Broadcast `workshop:chat-message` to room: { id, userId, displayName, avatarUrl, message, offset_ms, createdAt }

    **workshop:state-change** ({ workshopId: number, newStatus: string })
    - This is an INTERNAL event emitted by the server (not from client)
    - Used by start/end API routes to notify room
    - Broadcast `workshop:state-changed` to room: { status, startedAt?, endedAt? }

    Also handle disconnect: if user was in workshop rooms, broadcast leave.

    **index.ts updates:**
    Add the /workshop namespace following the exact pattern of /chat and /notifications:
    - Import registerWorkshopHandlers
    - Create `const workshopNs = io.of('/workshop')`
    - Apply authMiddleware
    - On connection: extract userId, join user-specific room, call registerWorkshopHandlers

    Also add `initWorkshopCrons()` import alongside existing cron imports.
  </action>
  <verify>TypeScript compiles. /workshop namespace registered in index.ts. All socket events defined.</verify>
  <done>Workshop Socket.IO namespace handles all signaling: room management, raise hand, speaker approval, co-host promotion, chat, and state changes.</done>
</task>

<task type="auto">
  <name>Task 2: Client-side workshop socket and chat hooks</name>
  <files>src/hooks/useWorkshopSocket.ts, src/hooks/useWorkshopChat.ts</files>
  <action>
    **useWorkshopSocket.ts:**
    Follow the pattern from src/hooks/useSocket.ts but connect to `/workshop` namespace.

    ```typescript
    export function useWorkshopSocket(workshopId: number | null)
    ```

    Returns: {
      socket: Socket | null,
      connected: boolean,
      workshopState: WorkshopState,
      attendees: AttendeeInfo[],
      raisedHands: number[],
      // Actions
      joinWorkshop: () => void,
      leaveWorkshop: () => void,
      raiseHand: () => void,
      lowerHand: () => void,
      approveSpeaker: (userId: number) => void,
      revokeSpeaker: (userId: number) => void,
      promoteCoHost: (userId: number) => void,
      demoteCoHost: (userId: number) => void,
      muteUser: (userId: number) => void,
      removeUser: (userId: number) => void,
    }

    Implementation:
    - Connect to io('/workshop') with same cookie-based auth as existing useSocket
    - On mount (when workshopId truthy), emit 'workshop:join'
    - On unmount, emit 'workshop:leave'
    - Listen for state events and update local state
    - Track attendees list from join/leave events
    - Track raised hands set
    - Expose action functions that emit socket events

    Define TypeScript interfaces:
    - WorkshopState: { status: 'scheduled' | 'lobby' | 'live' | 'ended' | 'cancelled', startedAt: Date | null, endedAt: Date | null, hostId: number, coHostIds: number[] }
    - AttendeeInfo: { userId: number, displayName: string, avatarUrl: string | null, isHost: boolean, isCoHost: boolean, canSpeak: boolean }

    **useWorkshopChat.ts:**
    Hook for workshop in-room chat.

    ```typescript
    export function useWorkshopChat(socket: Socket | null, workshopId: number | null)
    ```

    Returns: {
      messages: ChatMessage[],
      sendMessage: (text: string) => void,
    }

    Implementation:
    - Maintain messages array in state
    - Listen for 'workshop:chat-message' events, append to messages
    - sendMessage emits 'workshop:chat' with workshopId and message text
    - Messages append optimistically (or wait for server echo — follow existing chat pattern)

    Define: ChatMessage: { id: number, userId: number, displayName: string, avatarUrl: string | null, message: string, offsetMs: number, createdAt: string }
  </action>
  <verify>TypeScript compiles. Hooks export correctly. useWorkshopSocket connects to /workshop namespace.</verify>
  <done>Client-side hooks ready for workshop room UI to consume: socket connection with all actions, and real-time chat messages.</done>
</task>

</tasks>

<verification>
1. /workshop namespace initialized alongside /chat and /notifications
2. Socket events registered for join, leave, raise hand, approve speaker, chat
3. useWorkshopSocket connects and exposes all action functions
4. useWorkshopChat receives and sends chat messages
5. TypeScript compiles without errors
</verification>

<success_criteria>
- Socket.IO workshop signaling covers all real-time workshop interactions
- No dependency on Agora RTM — Socket.IO handles all signaling
- Client hooks provide clean API for workshop room components
- State machine transitions broadcast to all room participants
</success_criteria>

<output>
After completion, create `.planning/phases/05-workshops/05-05-SUMMARY.md`
</output>
