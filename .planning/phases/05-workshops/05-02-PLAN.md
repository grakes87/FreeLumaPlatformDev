---
phase: 05-workshops
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/workshop/agora-token.ts
  - src/lib/workshop/cloud-recording.ts
  - src/lib/workshop/recurrence.ts
  - src/lib/workshop/reminders.ts
autonomous: true

must_haves:
  truths:
    - "Server can generate time-limited Agora RTC tokens with role-based privileges"
    - "Server can start, query, and stop Agora Cloud Recording via REST API"
    - "RRULE strings can be parsed to generate recurring workshop instance dates"
    - "Reminder scheduler can identify workshops needing 1h and 15min notifications"
  artifacts:
    - path: "src/lib/workshop/agora-token.ts"
      provides: "generateAgoraToken function"
      exports: ["generateAgoraToken"]
    - path: "src/lib/workshop/cloud-recording.ts"
      provides: "Cloud Recording lifecycle functions"
      exports: ["acquireRecordingResource", "startCloudRecording", "stopCloudRecording", "queryRecordingStatus"]
    - path: "src/lib/workshop/recurrence.ts"
      provides: "RRULE helpers for series instance generation"
      exports: ["generateInstances", "getNextOccurrence"]
    - path: "src/lib/workshop/reminders.ts"
      provides: "Workshop reminder and no-show cron logic"
      exports: ["initWorkshopCrons"]
  key_links:
    - from: "src/lib/workshop/agora-token.ts"
      to: "agora-token npm package"
      via: "RtcTokenBuilder import"
      pattern: "RtcTokenBuilder"
    - from: "src/lib/workshop/recurrence.ts"
      to: "rrule npm package"
      via: "RRule import"
      pattern: "import.*rrule"
---

<objective>
Create the 4 server-side workshop utility modules: Agora token generation, Cloud Recording REST API wrapper, RRULE recurrence helpers, and workshop reminder/no-show cron scheduler.

Purpose: These utilities are consumed by workshop API routes and Socket.IO handlers. Building them independently in Wave 1 allows API routes (Wave 2) to import them immediately.
Output: 4 utility modules in src/lib/workshop/.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-workshops/05-CONTEXT.md
@.planning/phases/05-workshops/05-RESEARCH.md
@src/lib/email/scheduler.ts
@src/lib/cron/accountCleanup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Agora token generation and Cloud Recording wrapper</name>
  <files>src/lib/workshop/agora-token.ts, src/lib/workshop/cloud-recording.ts</files>
  <action>
    **agora-token.ts:**
    Create `generateAgoraToken(channelName: string, uid: number, role: 'host' | 'audience'): string`

    - Import `RtcTokenBuilder, RtcRole` from `agora-token`
    - Read AGORA_APP_ID and AGORA_APP_CERTIFICATE from process.env
    - Map 'host' -> RtcRole.PUBLISHER, 'audience' -> RtcRole.SUBSCRIBER
    - Token expires in 3600 seconds (1 hour)
    - Use `RtcTokenBuilder.buildTokenWithUid()`
    - Export the function
    - If env vars missing, throw descriptive error (don't silently return empty)

    **cloud-recording.ts:**
    Create 4 functions for the Cloud Recording REST API lifecycle:

    1. `acquireRecordingResource(channelName: string, recordingUid: number): Promise<string>` — Returns resourceId
    2. `startCloudRecording(channelName: string, recordingUid: number, token: string, resourceId: string): Promise<{ sid: string }>` — Starts composite mode recording, stores to B2
    3. `stopCloudRecording(channelName: string, recordingUid: number, resourceId: string, sid: string): Promise<{ fileList: Array<{ fileName: string; trackType: string }> }>` — Stops recording, returns file list
    4. `queryRecordingStatus(resourceId: string, sid: string): Promise<{ status: number; fileList?: Array<{ fileName: string }> }>` — Query recording status

    Implementation details:
    - Base URL: `https://api.agora.io/v1/apps/${AGORA_APP_ID}/cloud_recording`
    - Auth: `Basic ${Buffer.from(CUSTOMER_ID:CUSTOMER_SECRET).toString('base64')}`
    - Recording mode: `mix` (composite — all video streams mixed into one)
    - channelType: 1 (live broadcast)
    - streamTypes: 2 (audio + video)
    - maxIdleTime: 300 (5 min)
    - transcodingConfig: 1280x720, 30fps, 1500kbps, mixedVideoLayout: 1 (best fit)
    - avFileType: ['hls', 'mp4']
    - storageConfig: vendor 11 (S3-compatible), use B2 env vars (B2_BUCKET_NAME, B2_KEY_ID, B2_APP_KEY, B2_REGION)
    - fileNamePrefix: ['workshop-recordings']
    - extensionParams.endpoint: `https://s3.${B2_REGION}.backblazeb2.com`
    - Recording UID convention: 900000 + workshopId (avoids collision with real user IDs)
    - All functions handle error responses and throw with descriptive messages
    - Export a helper: `getRecordingUid(workshopId: number): number` that returns 900000 + workshopId
  </action>
  <verify>TypeScript compiles without errors. Functions exported correctly. Verify with `npx tsc --noEmit src/lib/workshop/agora-token.ts src/lib/workshop/cloud-recording.ts`.</verify>
  <done>Agora token generation and Cloud Recording REST API wrapper ready for use by workshop lifecycle API routes.</done>
</task>

<task type="auto">
  <name>Task 2: RRULE recurrence helpers</name>
  <files>src/lib/workshop/recurrence.ts</files>
  <action>
    Create recurrence utility functions using the `rrule` npm package:

    1. `generateInstances(rruleString: string, startDate: Date, horizonDays?: number): Date[]`
       - Default horizonDays: 90
       - Parse rrule string using `RRule.fromString()`
       - Use `.between(startDate, endDate, true)` to get occurrences
       - Return array of Date objects

    2. `getNextOccurrence(rruleString: string, afterDate?: Date): Date | null`
       - Default afterDate: now
       - Parse and use `.after(afterDate, false)` to get next occurrence
       - Return null if no more occurrences

    3. `buildRRuleString(frequency: 'daily' | 'weekly' | 'biweekly' | 'monthly', options?: { byDay?: string[]; count?: number; until?: Date }): string`
       - Build RRULE string from simplified inputs for the create workshop form
       - Map frequency to FREQ (DAILY, WEEKLY, MONTHLY)
       - biweekly = FREQ=WEEKLY;INTERVAL=2
       - byDay: ['MO', 'TU', etc.] -> BYDAY=MO,TU
       - count -> COUNT=N
       - until -> UNTIL=YYYYMMDDTHHMMSSZ
       - Return the RRULE string (without "RRULE:" prefix, just the params)

    4. `describeRRule(rruleString: string): string`
       - Human-readable description of a recurrence pattern
       - Use `RRule.fromString(rruleString).toText()` which rrule provides natively
       - Return string like "every week on Monday"

    All functions handle timezone via date-fns-tz:
    - Store host's timezone alongside RRULE
    - `generateInstancesInTimezone(rruleString: string, timeOfDay: string, timezone: string, startDate: Date, horizonDays?: number): Date[]`
       - Generates occurrences and sets time-of-day in host's timezone
       - Converts to UTC for storage
       - Uses `toZonedTime` / `fromZonedTime` from date-fns-tz
  </action>
  <verify>TypeScript compiles without errors. Test mentally: FREQ=WEEKLY;BYDAY=MO with startDate=2026-02-16 (Monday) generates consecutive Mondays.</verify>
  <done>RRULE recurrence utilities ready for workshop series creation and instance generation.</done>
</task>

<task type="auto">
  <name>Task 3: Workshop cron scheduler (reminders + no-show)</name>
  <files>src/lib/workshop/reminders.ts</files>
  <action>
    Create `initWorkshopCrons(): void` following the exact pattern from src/lib/email/scheduler.ts and src/lib/cron/accountCleanup.ts:
    - Use `node-cron` for scheduling
    - Use globalThis guard to prevent double-init in HMR

    **Cron 1: RSVP Reminders (runs every 5 minutes)**
    - Query workshops WHERE status='scheduled' AND scheduled_at BETWEEN NOW()+55min AND NOW()+65min (1h reminder window)
    - For each matching workshop, get all WorkshopAttendee WHERE status='rsvp'
    - Call `createNotification()` (lazy import from @/lib/notifications) with type='workshop_reminder', message about 1h until workshop
    - Similarly check scheduled_at BETWEEN NOW()+10min AND NOW()+20min for 15min reminder
    - Skip if notification already sent (check existing notification with group_key pattern `workshop_reminder:workshop:{id}:1h` or `:15m`)

    **Cron 2: No-Show Auto-Cancel (runs every minute)**
    - Query workshops WHERE status='scheduled' AND scheduled_at < NOW()-15min
    - For each, use a DB transaction:
      1. Re-read workshop status inside transaction (race condition guard per research pitfall 9)
      2. If still 'scheduled', update status to 'cancelled'
      3. Get all RSVP'd attendees and send cancellation notification
    - This handles the 15-min no-show rule

    **Cron 3: Series Instance Generation (runs daily at 4am UTC)**
    - Query active WorkshopSeries
    - For each series, find the latest Workshop instance (MAX scheduled_at)
    - If latest instance is within 30 days from now, generate new instances up to 90 days out
    - Use recurrence.ts `generateInstancesInTimezone()` to get new dates
    - Create Workshop rows for each new date (copy title, description, category_id from series)
    - Set agora_channel as `workshop-{newId}` after creation

    Export `initWorkshopCrons`.

    NOTE: The notification ENUM will need extending for 'workshop_reminder' and 'workshop_cancelled' types. Add a comment noting this dependency — the migration will be handled when extending notification types in the integration plan.
  </action>
  <verify>TypeScript compiles without errors. Function exports correctly. Cron patterns are valid node-cron expressions.</verify>
  <done>Workshop cron scheduler handles RSVP reminders (1h, 15min), no-show auto-cancel (15min), and rolling series instance generation.</done>
</task>

</tasks>

<verification>
1. All 4 files exist in src/lib/workshop/
2. TypeScript compiles without errors
3. agora-token.ts exports generateAgoraToken
4. cloud-recording.ts exports acquire, start, stop, query functions
5. recurrence.ts exports generateInstances, getNextOccurrence, buildRRuleString, describeRRule
6. reminders.ts exports initWorkshopCrons with 3 cron jobs
</verification>

<success_criteria>
- Server-side workshop utilities are complete and ready for consumption by API routes
- Agora token generation uses RtcTokenBuilder with role-based privileges
- Cloud Recording wrapper covers full lifecycle (acquire -> start -> stop -> query)
- RRULE helpers generate correct recurring dates with timezone awareness
- Cron scheduler handles reminders, no-show, and series instance generation
</success_criteria>

<output>
After completion, create `.planning/phases/05-workshops/05-02-SUMMARY.md`
</output>
