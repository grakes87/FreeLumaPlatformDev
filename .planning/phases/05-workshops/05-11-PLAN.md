---
phase: 05-workshops
plan: 11
type: execute
wave: 5
depends_on: [05-05, 05-06, 05-10]
files_modified:
  - src/app/(app)/workshops/[id]/live/page.tsx
  - src/components/workshop/WorkshopLobby.tsx
  - src/components/workshop/WorkshopRoom.tsx
  - src/components/workshop/WorkshopVideo.tsx
  - src/hooks/useWorkshopState.ts
autonomous: true

must_haves:
  truths:
    - "Host can open lobby and start workshop from lobby"
    - "Attendees see waiting room until host starts"
    - "When workshop goes live, Agora video connects for host/co-hosts"
    - "Attendees see host/co-host video feeds in gallery"
    - "Workshop room is fully immersive (hides bottom nav)"
  artifacts:
    - path: "src/app/(app)/workshops/[id]/live/page.tsx"
      provides: "Live workshop room page (dynamic import, ssr:false)"
    - path: "src/components/workshop/WorkshopLobby.tsx"
      provides: "Pre-join waiting room"
    - path: "src/components/workshop/WorkshopRoom.tsx"
      provides: "Main workshop room container"
    - path: "src/components/workshop/WorkshopVideo.tsx"
      provides: "Agora video grid for host + co-hosts"
    - path: "src/hooks/useWorkshopState.ts"
      provides: "Workshop lifecycle state machine hook"
      exports: ["useWorkshopState"]
  key_links:
    - from: "src/app/(app)/workshops/[id]/live/page.tsx"
      to: "src/components/workshop/WorkshopRoom.tsx"
      via: "dynamic import with ssr:false"
      pattern: "dynamic.*ssr.*false"
    - from: "src/components/workshop/WorkshopVideo.tsx"
      to: "agora-rtc-react"
      via: "AgoraRTCProvider, useJoin, usePublish"
      pattern: "agora-rtc-react"
---

<objective>
Create the live workshop room with lobby/waiting room, Agora video integration for host/co-host video feeds, and the workshop lifecycle state machine. This is the core live experience.

Purpose: The live room is the heart of the workshop feature — connecting hosts and attendees via video, audio, and the Socket.IO signaling layer.
Output: Live page with dynamic Agora import, lobby component, room container, video grid, state machine hook.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-workshops/05-CONTEXT.md
@.planning/phases/05-workshops/05-RESEARCH.md
@src/hooks/useWorkshopSocket.ts
@src/contexts/ImmersiveContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Workshop state machine hook and live page</name>
  <files>src/hooks/useWorkshopState.ts, src/app/(app)/workshops/[id]/live/page.tsx</files>
  <action>
    **useWorkshopState.ts:**
    Workshop lifecycle state machine hook.

    ```typescript
    export function useWorkshopState(workshopId: number)
    ```

    Returns: {
      state: 'loading' | 'lobby' | 'live' | 'ended' | 'error',
      workshop: WorkshopData | null,
      isHost: boolean,
      isCoHost: boolean,
      canSpeak: boolean,
      agoraToken: string | null,
      agoraChannel: string | null,
      agoraUid: number | null,
      agoraRole: 'host' | 'audience',
      error: string | null,
      // Actions
      startWorkshop: () => Promise<void>,
      endWorkshop: () => Promise<void>,
      refreshToken: () => Promise<void>,
    }

    Implementation:
    - On mount: fetch workshop detail from /api/workshops/[id]
    - Determine initial state from workshop.status
    - Listen for Socket.IO state changes via useWorkshopSocket
    - When transitioning to 'live':
      1. Fetch Agora token from /api/workshops/[id]/token
      2. Set agoraToken, agoraChannel, agoraUid, agoraRole
    - startWorkshop: POST /api/workshops/[id]/start (host only)
    - endWorkshop: POST /api/workshops/[id]/end (host only)
    - refreshToken: re-fetch token (for long workshops, token expires in 1h)
    - Auto-refresh token every 50 minutes while live

    **live/page.tsx:**
    'use client' page with CRITICAL ssr:false dynamic import.

    ```typescript
    import dynamic from 'next/dynamic';

    const WorkshopRoom = dynamic(
      () => import('@/components/workshop/WorkshopRoom'),
      { ssr: false, loading: () => <WorkshopLoadingScreen /> }
    );
    ```

    Layout:
    - Set ImmersiveContext to hide bottom nav (same pattern as chat conversation)
    - Render WorkshopRoom with workshopId from params
    - Full-screen fixed layout (inset-0 z-40)
    - Back button to exit workshop (with confirmation if live)

    IMPORTANT: Agora SDK accesses `window` and `navigator` on import. Dynamic import with ssr:false is MANDATORY. This is the #1 pitfall from research.
  </action>
  <verify>TypeScript compiles. Dynamic import uses ssr:false. State machine transitions correctly.</verify>
  <done>Workshop state machine manages lifecycle and Agora token. Live page uses dynamic import to avoid SSR crash.</done>
</task>

<task type="auto">
  <name>Task 2: Workshop lobby and room container</name>
  <files>src/components/workshop/WorkshopLobby.tsx, src/components/workshop/WorkshopRoom.tsx</files>
  <action>
    **WorkshopLobby.tsx:**
    Pre-join waiting room shown before workshop goes live.

    Props: {
      workshop: WorkshopData,
      isHost: boolean,
      attendees: AttendeeInfo[],
      onStart: () => void, // host only
    }

    Layout:
    - Workshop title at top
    - Countdown timer to scheduled_at (if > 0 seconds remaining)
    - "Waiting for host to start..." message (for attendees)
    - Attendee list: avatars + names of who's in the lobby
    - Host view: "Start Workshop" button (large, prominent, green)
    - Camera/mic preview (optional — can be added later)
    - Tips section: "You will be able to watch the host's video and raise your hand to speak"

    Styling:
    - Dark background (workshop room aesthetic)
    - Centered content
    - Animated waiting dots or spinner

    **WorkshopRoom.tsx:**
    Main workshop room container that switches between lobby and live views.

    Props: { workshopId: number }

    Implementation:
    - Use useWorkshopState(workshopId) for lifecycle
    - Use useWorkshopSocket(workshopId) for real-time signaling
    - Use useWorkshopChat(socket, workshopId) for in-room chat

    Render based on state:
    - 'loading': full-screen loading spinner
    - 'lobby': <WorkshopLobby />
    - 'live': <WorkshopVideoArea /> + sidebar (chat/participants/notes)
    - 'ended': redirect to workshop detail or show WorkshopSummary
    - 'error': error message with retry

    When state === 'live':
    - Layout: video area (main) + collapsible sidebar (chat/participants/notes tabs)
    - Mobile: video stacked above chat (full height)
    - Desktop: video left (70%) + sidebar right (30%)
    - Top bar: workshop title, attendee count, duration timer, leave button
    - If host: additional controls (end workshop, screen share toggle)
  </action>
  <verify>TypeScript compiles. Room switches between lobby and live. Lobby shows countdown and start button for host.</verify>
  <done>Workshop room container manages lobby -> live transition with proper layout for video and sidebar.</done>
</task>

<task type="auto">
  <name>Task 3: Agora video grid component</name>
  <files>src/components/workshop/WorkshopVideo.tsx</files>
  <action>
    Agora video integration for displaying host and co-host video feeds.

    CRITICAL: This component is ONLY rendered inside dynamically-imported WorkshopRoom (ssr:false), so it's safe to import agora-rtc-react at the top level.

    Props: {
      channelName: string,
      token: string,
      uid: number,
      role: 'host' | 'audience',
      isHost: boolean,
      isCoHost: boolean,
    }

    Implementation using agora-rtc-react hooks:

    ```typescript
    import AgoraRTC, {
      AgoraRTCProvider,
      useJoin,
      useLocalMicrophoneTrack,
      useLocalCameraTrack,
      usePublish,
      useRemoteUsers,
      RemoteUser,
      LocalVideoTrack,
    } from 'agora-rtc-react';
    ```

    1. Create Agora client with `mode: 'live'`, `codec: 'vp8'`
    2. Set client role: host/co-host -> 'host', attendee -> 'audience'
    3. Use useJoin to join channel with token and uid
    4. For hosts/co-hosts: create local camera and microphone tracks
    5. For hosts/co-hosts: publish local tracks
    6. For all: subscribe to remote users' video/audio
    7. Display video grid:
       - Host's local video (if host/co-host and camera on)
       - Remote users' videos (other hosts/co-hosts)
       - Gallery layout: 1 video = full, 2 = side by side, 3-4 = 2x2 grid
    8. Audio controls bar at bottom:
       - Microphone toggle (mute/unmute — only for host/co-host/approved speaker)
       - Camera toggle (only for host/co-host)
       - Screen share button (host/co-host only — creates separate client)
    9. Connection state indicator (connecting, connected, reconnecting)

    Handle role switching:
    - When attendee is approved as speaker (can_speak=true from Socket.IO):
      - Switch role to 'host' via client.setClientRole('host')
      - Create and publish microphone track only (no video per CONTEXT decision)
    - When speaker is revoked:
      - Unpublish tracks FIRST
      - Then switch role to 'audience'

    Screen sharing (host/co-host):
    - Create separate Agora client for screen share (screenClient)
    - Screen share UID = user.id + 100000 (per research)
    - Use separate AgoraRTCScreenShareProvider or manual client
    - On screen share start/stop, emit Socket.IO event for layout tracking

    Error handling:
    - If Agora connection fails, show error with "Retry" button
    - If env vars not set (no AGORA_APP_ID), show "Video not configured" message
  </action>
  <verify>TypeScript compiles. Agora client uses mode:'live'. Host publishes video+audio, audience subscribes only. Screen share uses separate client with UID+100000.</verify>
  <done>Agora video grid renders host/co-host feeds in gallery layout with mic/camera/screen share controls and proper role management.</done>
</task>

</tasks>

<verification>
1. /workshops/[id]/live loads without SSR crash (dynamic import)
2. Lobby shows when workshop is scheduled/lobby status
3. Host can click "Start Workshop" to go live
4. When live: Agora video connects and shows host feed
5. Attendees see host video without publishing their own
6. Approved speakers can unmute audio
7. Screen sharing uses separate Agora client
8. Workshop room hides bottom nav (ImmersiveContext)
</verification>

<success_criteria>
- Live workshop room works end-to-end from lobby through live video
- Agora integration follows all research anti-patterns (mode:live, ssr:false, separate screen share client)
- Role-based video/audio publishing: hosts publish video+audio, speakers publish audio only, audience subscribes only
- Clean state machine transitions with Socket.IO signaling
- Full-screen immersive layout
</success_criteria>

<output>
After completion, create `.planning/phases/05-workshops/05-11-SUMMARY.md`
</output>
